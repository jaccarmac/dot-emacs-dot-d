Emacs is by far the most important application I use to develop. It is also the
most fun to configure application I use, period. That means configuring it can
be a daunting task. This document is my attempt to create an Emacs setup that
is comprehensive and easy to extend. To this end, I've made it a literate Org
file, which means it is organized, easy to modify, and easily convertible to
web page. It is also version controlled.

Now, for some code.

* Bootstrap.

  To load various packages and initialize them succinctly, I use =quelpa= and
  =use-package=. =quelpa= builds packages from source so I can stay on the
  bleeding edge. =use-package= loads and initializes the packages in a compact
  and readable macro. Unfortunately, one cannot load those packages using
  them. Fortunately, the bootstrapping process is relatively painless.

  The =quelpa= bootstrap snippet comes straight from the project's GitHub
  page. I use the non-auto-updating version.

  #+NAME: quelpa
  #+BEGIN_SRC emacs-lisp
    (package-initialize)
    (unless (require 'quelpa nil t)
      (with-temp-buffer
        (url-insert-file-contents
         "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
        (eval-buffer)))
  #+END_SRC

  Because of the last snippet, =use-package= can be downloaded using the
  =quelpa= function, but it must be loaded manually. (Manually being a
  one-liner. :-)

  #+NAME: use-package
  #+BEGIN_SRC emacs-lisp
    (quelpa 'use-package)
    (require 'use-package)
  #+END_SRC

  After the actual boostrapping I can use a small convenience macro I wrote
  myself to combine =quelpa= and =use-package=. It is called =quse-package= and
  is fetched via (you guessed it) =quelpa=.

  #+NAME: quse-package
  #+BEGIN_SRC emacs-lisp
    (quelpa '(quse-package :fetcher github
                           :repo "jaccarmac/quse-package"
                           :files ("tangled/quse-package.el")))
    (require 'quse-package)
  #+END_SRC

* Improve Emacs' interface.

  Vanilla Emacs is usable, but not usable enough to allow me to be
  productive. A few small packages allow me to actually function in the editor.

  Phil Hagelberg's =better-defaults= is a good start, including several
  one-line configuration options and usability rebinds.

  #+NAME: better-defaults
  #+BEGIN_SRC emacs-lisp
    (quse-package better-defaults)
  #+END_SRC

  On top of the sensible settings in =better-defaults=, I like to set
  =fill-column= to a sane value that doesn't depend on Emacs' frame
  size.

  #+NAME: fill-column
  #+BEGIN_SRC emacs-lisp
    (setq-default fill-column 79)
  #+END_SRC

  It's also nice to not have to deal with the splash screen every time Emacs
  starts.

  #+NAME: inhibit-splash-screen
  #+BEGIN_SRC emacs-lisp
    (setq-default inhibit-splash-screen t)
  #+END_SRC

  Exposing Emacs' multi-branch undo and redo feature graphically is
  fantastically useful. Tony Cubitt's =undo-tree-mode= does just that.

  #+NAME: undo-tree
  #+BEGIN_SRC emacs-lisp
    (quse-package undo-tree
                  :init (global-undo-tree-mode))
  #+END_SRC

  Donald Ephraim Curtis had made a great port of Vim Powerline. It is helpful
  for keeping track of location in a file, and it looks pretty.

  #+NAME: powerline
  #+BEGIN_SRC emacs-lisp
    (quse-package powerline
                  :init (powerline-default-theme))
  #+END_SRC

  I have used many themes for Emacs during my time using it. I tend to come
  back to kuanyui's =moe-theme= due to its amount of contrast and variety of
  faces.

  #+NAME: moe-theme
  #+BEGIN_SRC emacs-lisp
    (quse-package moe-theme
                  :init (load-theme 'moe-dark t))
  #+END_SRC

  I'm a lazy Lisper, so I have never taken the time to learn =paredit=
  properly. Matus Goljer has created a =smartparens= package that makes many
  paren-editing commands automatic.

  #+NAME: smartparens
  #+BEGIN_SRC emacs-lisp
    (quse-package smartparens
                  :init (smartparens-global-mode))
  #+END_SRC

* Manage my money.

  Ledger is a fantastic personal accounting application. It has a ton of
  features, but it relatively easy to configure in plain text. It comes with an
  Emacs mode.

  #+NAME: ledger-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package ledger-mode)
  #+END_SRC

* Manage projects.

  One-off-file hacking is great, but most of what I do is done in the context
  of a project, often one too big to fit inside my head. The following packages
  integrate tools that do the legwork of project management with Emacs.

  Bozhidar Batsov's =projectile= is an all-inclusive project management
  navigator and indexer for Emacs. The indexing it does is especially useful,
  letting you grep an entire project with a simple key chord.

  #+NAME: projectile
  #+BEGIN_SRC emacs-lisp
    (quse-package projectile
                  :init (projectile-global-mode))
  #+END_SRC

  Git is the modern king of version control. The Magit project turns Emacs into
  an extremely powerful interface to it. I find that key chords are much more
  efficient than terminal commands after a few days' practice.

  #+NAME: magit
  #+BEGIN_SRC emacs-lisp
    (quse-package magit)
  #+END_SRC

* Complete symbols.

  It's nearly impossible to work with large projects or avoid misspellings
  without a good, always-accessible completion framework. The Emacs community
  is split between using Company and Auto-Complete. I've used Auto-Complete for
  quite a while and have no pressing reason to switch. Its initialization is
  rather simple; Sources are initialized later with the modes they are
  associated with.

  #+NAME: auto-complete
  #+BEGIN_SRC emacs-lisp
    (quse-package auto-complete
                  :init (progn (require 'auto-complete-config)
                               (ac-config-default)))
  #+END_SRC

* Clojure.

  Clojure is a fantastic Lisp that gives me access to the JVM without having to
  deal with Java.

  CIDER is, in my opinion, the best way to edit Clojure in Emacs, bar
  none. Loading is done in the standard quelpa way; The configuration options
  are taken from CIDER's GitHub page.

  #+NAME: cider
  #+BEGIN_SRC emacs-lisp
    (quse-package cider
                  :init (progn
                          (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
                          (setq cider-repl-tab-command 'indent-for-tab-command)))
  #+END_SRC

  CIDER can be integrated with Auto-Complete painlessly by using the ac-cider
  package.

  #+NAME: ac-cider
  #+BEGIN_SRC emacs-lisp
    (quse-package ac-cider
                  :init (progn (add-hook 'cider-mode-hook 'ac-cider-setup)
                               (add-hook 'cider-repl-mode-hook 'ac-cider-setup)))
  #+END_SRC

* Hack with Common Lisp.

  While most of my Lisp-writing has been in Clojure, the majority of my
  Lisp-learning has been in Common Lisp. Fanboys say there's nothing you can't
  do with CL, and, while I don't have enough experience to confirm or deny
  this, I always enjoy exploring the language. The Emacs/CL ecosystem is
  amazing as well.

  SLIME is indescribably good. 'Nuff said. As for the configuration, I set SBCL
  as my preferred Lisp, and tell SLIME to look fancy. In addition, I tell SLIME
  where to find the Common Lisp Hyperspec so I can look up HTML documentation
  on the fly.

  #+NAME: slime
  #+BEGIN_SRC emacs-lisp
    (quse-package slime
                  :init (progn
                          (setq inferior-lisp-program "sbcl")
                          (setq common-lisp-hyperspec-root
                                "/usr/share/doc/hyperspec/")
                          (setq slime-contribs '(slime-fancy))
                          (slime-setup)))
  #+END_SRC

  Integrating Auto-Complete and SLIME is painless, thanks to the work of Steve
  Purcell.

  #+NAME: ac-slime
  #+BEGIN_SRC emacs-lisp
    (quse-package ac-slime
                  :init (progn (add-hook 'slime-mode-hook 'set-up-slime-ac)
                               (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
                               (eval-after-load "auto-complete"
                                 '(add-to-list 'ac-modes 'slime-repl-mode))))
  #+END_SRC

* Edit web applications.

  Managing modes to edit the dozens of new file formats for a new web project
  every month is a nightmare. So much so I don't like to talk about it. I've
  found that =web-mode.el= does a pretty good job of managing them
  automagically.

  #+NAME: web-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package web-mode
                  :init (progn
                          (add-to-list 'auto-mode-alist
                                       '("\\.html?\\'" . web-mode))
                          (add-to-list 'auto-mode-alist
                                       '("\\.css?\\'" . web-mode))
                          (add-to-list 'auto-mode-alist
                                       '("\\.js?\\'" . web-mode))))
  #+END_SRC

* Steal Java-editing features from Eclipse.

  Trying to edit Java with just Emacs is a nightmare. I tried it for a while,
  but eventually caved into practicality and installed Eclipse, eclim, and
  =emacs-eclim=. The trio of software packages work together to use Eclipse's
  editing features and completion in Emacs. The configuration here comes
  straight from the =emacs-eclim= website, converted to a slightly strange form
  because of the project's package structure.

  #+NAME: emacs-eclim
  #+BEGIN_SRC emacs-lisp
    (quelpa 'emacs-eclim)
    (use-package eclim :init (global-eclim-mode))
    (use-package ac-emacs-eclim-source :init (ac-emacs-eclim-config))
  #+END_SRC

** Include YASnippet.

   Some features of =emacs-eclim= depend on having YASnippet, a popular Emacs
   snippet package, installed. I don't use YASnippet directly, only through
   =emacs-eclim=, but I may change my mind in the future.

   #+NAME: yasnippet
   #+BEGIN_SRC emacs-lisp
     (quse-package yasnippet)
   #+END_SRC

* Edit and complete Nim.

  Nim is a systems programming languages that compiles to C, C++, ObjC, and
  JavaScript. It's the latest toy language I am trying to learn. Two packages
  provided by a single repository provide all the features needed to edit Nim
  in Emacs.

  #+NAME: nim-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package nim-mode)
  #+END_SRC

  #+NAME: ac-nim
  #+BEGIN_SRC emacs-lisp
    (quse-package ac-nim :init (eval-after-load 'nim-mode
                                 '(add-hook 'nim-mode-hook 'ac-nim-enable)))
  #+END_SRC

* View Markdown.

  I prefer Org to Markdown in every situation, but sometimes it is necessary to
  be able to read Markdown. Good thing there's a mode on MELPA!

  #+NAME: markdown-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package markdown-mode)
  #+END_SRC

* Tangle source code.

  All files get tangled to the directory that this file is in.

** =init.el=

   #+BEGIN_SRC emacs-lisp :noweb no-export :tangle init.el
     <<quelpa>>

     <<use-package>>

     <<quse-package>>

     <<better-defaults>>

     <<fill-column>>

     <<inhibit-splash-screen>>

     <<undo-tree>>

     <<powerline>>

     <<moe-theme>>

     <<smartparens>>

     <<ledger-mode>>

     <<projectile>>

     <<magit>>

     <<auto-complete>>

     <<cider>>

     <<ac-cider>>

     <<slime>>

     <<ac-slime>>

     <<web-mode>>

     <<emacs-eclim>>

     <<yasnippet>>

     <<nim-mode>>

     <<ac-nim>>

     <<markdown-mode>>
   #+END_SRC
