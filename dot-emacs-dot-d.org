#+TITLE: =.emacs.d=
#+AUTHOR: Jacob MacDonald
#+PROPERTY: header-args :noweb yes :padline no

#+BEGIN_SRC text :tangle UNLICENSE
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
  software, either in source code form or as a compiled binary, for any purpose,
  commercial or non-commercial, and by any means.

  In jurisdictions that recognize copyright laws, the author or authors of this
  software dedicate any and all copyright interest in the software to the public
  domain. We make this dedication for the benefit of the public at large and to
  the detriment of our heirs and successors. We intend this dedication to be an
  overt act of relinquishment in perpetuity of all present and future rights to
  this software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
  AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
#+END_SRC

Emacs is by far the most important application I use to develop. It is also the
most fun to configure application I use, period. That means configuring it can
be a daunting task. This document is my attempt to create an Emacs setup that
is comprehensive and easy to extend. To this end, I've made it a literate Org
file, which means it is organized, easy to modify, and easily convertible to
web page. It is also version controlled.

Now, for some code.

* Bootstrap.

  To load various packages and initialize them succinctly, I use =quelpa= and
  =use-package=. =quelpa= builds packages from source so I can stay on the
  bleeding edge. =use-package= loads and initializes the packages in a compact
  and readable macro. Unfortunately, one cannot load those packages using
  them. Fortunately, the bootstrapping process is relatively painless.

  The =quelpa= bootstrap snippet comes straight from the project's GitHub
  page. I use the non-auto-updating version.

  #+BEGIN_SRC emacs-lisp :noweb-ref quelpa
    (package-initialize)
    (setf quelpa-update-melpa-p nil)
    (unless (require 'quelpa nil t)
      (with-temp-buffer
        (url-insert-file-contents
         "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
        (eval-buffer)))
  #+END_SRC

  Because of the last snippet, =use-package= can be downloaded using the
  =quelpa= function, but it must be loaded manually. (Manually being a
  one-liner. :-)

  #+BEGIN_SRC emacs-lisp :noweb-ref use-package
    (quelpa 'use-package)
    (require 'use-package)
  #+END_SRC

  After the actual boostrapping I can use a small convenience macro I wrote
  myself to combine =quelpa= and =use-package=. It is called =quse-package= and
  is fetched via (you guessed it) =quelpa=.

  #+BEGIN_SRC emacs-lisp :noweb-ref quse-package
    (quelpa '(quse-package :fetcher github :repo "jaccarmac/quse-package"))
    (require 'quse-package)
  #+END_SRC

* Improve Emacs' interface.

  Vanilla Emacs is usable, but not usable enough to allow me to be
  productive. A few small packages allow me to actually function in the editor.

  Phil Hagelberg's =better-defaults= is a good start, including several
  one-line configuration options and usability rebinds.

  #+BEGIN_SRC emacs-lisp :noweb-ref better-defaults
    (quse-package better-defaults)
  #+END_SRC

  Emacs recently changed the way it handles saving the position of the point in
  visited files. =better-defaults= uses the old way (setting a variable) while
  newer versions of Emacs use a mode for the same behavior. I'm almost ready to
  submit a pull request to =better-defaults=, but don't understand the nuts and
  bolts of the change completely. Thus, here is a monkey-patch to fix the
  behavior for myself.

  #+BEGIN_SRC emacs-lisp :noweb-ref save-place-mode
    (use-package saveplace :init
      (when (fboundp 'save-place-mode) (save-place-mode)))
  #+END_SRC

  And while =better-defaults= enables Ido mode and Ido flex matching, both of
  which are very useful settings, it does not enable Ido everyhwere, which is
  very useful. Fully converting Emacs to use Ido has to be done in several
  steps. First comes the basic Ido setup included in =better-defaults=. Then,
  ~ido-ubiquitous~, a slightly more dangerous built-in function, is
  activated. Finally, several more packages are used to fill in the
  gaps. Namely, they are =ido-ubiquitous= for a few edge cases, =smex= to
  replace the =M-x= prompt, =ido-yes-or-no= to replace binary prompts, and
  =crm-custom.el= to replace =completing-read-multiple=.

  #+BEGIN_SRC emacs-lisp :noweb-ref ido-really-everywhere
    (ido-everywhere)

    (quse-package ido-ubiquitous
                  :init
                  (ido-ubiquitous-mode)
                  (setf org-completion-use-ido t)
                  (setf magit-completing-read-function 'magit-ido-completing-read))

    (quse-package ido-yes-or-no :init (ido-yes-or-no-mode))

    (quse-package crm-custom :init (crm-custom-mode))

    (quse-package smex
                  :init (smex-initialize)
                  :bind (("M-x" . smex)
                         ("M-X" . smex-major-mode-commands)
                         ("C-c C-c M-x" . execute-extended-command)))
  #+END_SRC

  On top of the sensible settings in =better-defaults=, I like to set
  =fill-column= to a sane value that doesn't depend on Emacs' frame
  size.

  #+BEGIN_SRC emacs-lisp :noweb-ref fill-column
    (setq-default fill-column 79)
  #+END_SRC

  Unix UTF-8 encoding is a better sensible default for encoding than whatever
  platform-dependent value Emacs uses by default.

  #+BEGIN_SRC emacs-lisp :noweb-ref prefer-coding-system
    (prefer-coding-system 'utf-8-unix)
  #+END_SRC

  It's also nice to not have to deal with the splash screen every time Emacs
  starts.

  #+BEGIN_SRC emacs-lisp :noweb-ref inhibit-splash-screen
    (setq-default inhibit-splash-screen t)
  #+END_SRC

  Exposing Emacs' multi-branch undo and redo feature graphically is
  fantastically useful. Tony Cubitt's =undo-tree-mode= does just that.

  #+BEGIN_SRC emacs-lisp :noweb-ref undo-tree
    (quse-package undo-tree :init (global-undo-tree-mode))
  #+END_SRC

  Donald Ephraim Curtis had made a great port of Vim Powerline. It is helpful
  for keeping track of location in a file, and it looks pretty.

  #+BEGIN_SRC emacs-lisp :noweb-ref powerline
    (quse-package powerline :init (powerline-default-theme))
  #+END_SRC

  I have used many themes for Emacs during my time using it. I tend to come
  back to kuanyui's =moe-theme= due to its amount of contrast and variety of
  faces.

  #+BEGIN_SRC emacs-lisp :noweb-ref moe-theme
    (quse-package moe-theme :config (load-theme 'moe-dark t))
  #+END_SRC

  I also enjoy using a pleasant monospace font. It's pretty easy to get Emacs
  to recognize your global GTK settings on a Linux box, but for Windows
  machines the font needs to be set programmatically or in the
  registry. Explicitly using Iosevka works on all systems with the font
  installed, and defaults back to the font provided by the system if Iosevka
  isn't there.

  #+BEGIN_SRC emacs-lisp :noweb-ref face-attribute-font
    (set-face-attribute 'default nil :font "Iosevka")
  #+END_SRC

  The =smartparens= package is like =paredit= plus a bunch of nice extras. I
  enable the strict mode globally and use the maintainer's default keybindings.

  #+BEGIN_SRC emacs-lisp :noweb-ref smartparens
    (quse-package smartparens
                  :init
                  (smartparens-global-mode)
                  (smartparens-global-strict-mode)
                  (require 'smartparens-config)
                  (sp-use-smartparens-bindings))
  #+END_SRC

* Make copying in Dired marginally better.

  `dired-dwim-target` makes Dired Do What I Mean when copying. This means I can
  open two Dired windows in disparate locations and copy files between them
  without having to edit long pathnames.

  #+BEGIN_SRC emacs-lisp :noweb-ref dired-dwim-target
    (setf dired-dwim-target t)
  #+END_SRC

* Install a recent version of Org mode.

  It works fine without installing the bleeding edge, but that's no fun. And
  installing the bleeding edge is just too easy...

  Org mode is so awesome that I use it as my default mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref org
    (quse-package (org :fetcher git
                       :url "git://orgmode.org/org-mode.git"
                       :files ("lisp/*.el"
                               "contrib/lisp/*.el"
                               "doc/dir"
                               "doc/*.texi"))
                  :init
                  (setf default-major-mode 'org-mode))
  #+END_SRC

** Create presentations in Org.

   Org comes preloaded with facilities for Beamer export, which produces
   high-quality LaTeX presentations. I prefer something lighter and webbier,
   and that thing is reveal.js, which also has an Org exporter. However, this
   one needs to be installed.

   #+BEGIN_SRC emacs-lisp :noweb-ref ox-reveal
     (quse-package ox-reveal)
   #+END_SRC

** Improve Org's LaTeX export.

   I end up writing a lot of papers in Org and exporting via LaTeX for nice
   PDFs. After a few months of doing this with a more-or-less vanilla Org
   setup, I've found that doing citations properly is difficult. That is the
   motivation for the changes below, which consist of:

   1. Setting the export process to =latexmk=.

      #+BEGIN_SRC emacs-lisp :noweb-ref org-pdf-latexmk
        (setf org-latex-pdf-process (list "latexmk -f -pdf %f"))
      #+END_SRC

*** Allow APA-style export from Org.

    To use document classes that aren't ~article~, ~report~, or ~book~, the
    class needs to be registered in Org. I took the samples from the existing
    ~org-latex-classes~ and added one for the LaTeX ~apa6~ package.

    #+BEGIN_SRC emacs-lisp :noweb-ref org-latex-classes-apa6
      (add-to-list 'org-latex-classes
                   '("apa6"
                     "\\documentclass[man,12pt]{apa6}"
                     ("\\section{%s}" . "\\section*{%s}")
                     ("\\subsection{%s}" . "\\subsection*{%s}")
                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    #+END_SRC

* Manage my money.

  Ledger is a fantastic personal accounting application. It has a ton of
  features, but it relatively easy to configure in plain text. It comes with an
  Emacs mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref ledger-mode
    (quse-package ledger-mode
                  :init (add-to-list 'auto-mode-alist
                                     '("ledger/.*\\.dat\\'" . ledger-mode)))
  #+END_SRC

* Generate and secure passwords.

  I use =password-store= to manage and generate all my passwords. This utility
  stores passwords in text files encrypted by my GPG key, and can copy them to
  the system clipboard when I need to use them. A work-in-progress Emacs mode
  is included in the distribution and cloned and installed in the following
  snippet.

  #+BEGIN_SRC emacs-lisp :noweb-ref password-store
    (quse-package password-store)
  #+END_SRC

* Manage projects.

  One-off-file hacking is great, but most of what I do is done in the context
  of a project, often one too big to fit inside my head. The following packages
  integrate tools that do the legwork of project management with Emacs.

  Bozhidar Batsov's =projectile= is an all-inclusive project management
  navigator and indexer for Emacs. The indexing it does is especially useful,
  letting you grep an entire project with a simple key chord. I force the
  indexing to use fast Unix-y tools even on Windows. Even though this method is
  faster than using Emacs Lisp indexing, note that it requires extra tools,
  namely Git and =find=, to be installed.

  #+BEGIN_SRC emacs-lisp :noweb-ref projectile
    (quse-package projectile
                  :init
                  (projectile-global-mode)
                  (setf projectile-switch-project-action 'projectile-dired)
                  (setf projectile-indexing-method 'alien))
  #+END_SRC

  Git is the modern king of version control. The Magit project turns Emacs into
  an extremely powerful interface to it. I find that key chords are much more
  efficient than terminal commands after a few days' practice.

  #+BEGIN_SRC emacs-lisp :noweb-ref magit
    (quse-package magit)
  #+END_SRC

  Using SSH Git remotes on Windows is a nightmare due to how difficult it is to
  get ssh-agent's environment variables into an Emacs not started in Cygwin or
  MSYS. Thankfully, the Magit maintainers have written a package to manage said
  environment variables, just for Emacs, automatically!

  #+BEGIN_SRC emacs-lisp :noweb-ref ssh-agency
    (quse-package ssh-agency)
  #+END_SRC

* Complete symbols.

  It's nearly impossible to work with large projects or avoid misspellings
  without a good, always-accessible completion framework. The Emacs community
  is split between using Company and Auto-Complete. I've used Auto-Complete for
  quite a while and have no pressing reason to switch. Its initialization is
  rather simple; Sources are initialized later with the modes they are
  associated with.

  #+BEGIN_SRC emacs-lisp :noweb-ref auto-complete
    (quse-package auto-complete
                  :init
                  (require 'auto-complete-config)
                  (ac-config-default))
  #+END_SRC

* Clojure.

  Clojure is a fantastic Lisp that gives me access to the JVM without having to
  deal with Java.

  CIDER is, in my opinion, the best way to edit Clojure in Emacs, bar
  none. Loading is done in the standard quelpa way; The configuration options
  are taken from CIDER's GitHub page. I prefer Boot over Leiningen, so I set
  Boot as my default REPL.

  #+BEGIN_SRC emacs-lisp :noweb-ref cider
    (quse-package cider
                  :init
                  (setf cider-repl-tab-command 'indent-for-tab-command)
                  (setf cider-default-repl-command "boot"))
  #+END_SRC

  CIDER can be integrated with Auto-Complete painlessly by using the ac-cider
  package.

  #+BEGIN_SRC emacs-lisp :noweb-ref ac-cider
    (quse-package ac-cider
                  :init
                  (add-hook 'cider-mode-hook 'ac-cider-setup)
                  (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
                  (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
                  (add-hook 'cider-repl-mode-hook 'ac-flyspell-workaround)
                  (add-hook 'cider-clojure-interaction-mode-hook 'ac-cider-setup)
                  (add-hook 'cider-clojure-interaction-mode-hook 'ac-flyspell-workaround)
                  (eval-after-load "auto-complete"
                    '(progn
                       (add-to-list 'ac-modes 'cider-mode)
                       (add-to-list 'ac-modes 'cider-repl-mode)
                       (add-to-list 'ac-modes 'cider-clojure-interaction-mode))))
  #+END_SRC

* Hack with Common Lisp.

  While most of my Lisp-writing has been in Clojure, the majority of my
  Lisp-learning has been in Common Lisp. Fanboys say there's nothing you can't
  do with CL, and, while I don't have enough experience to confirm or deny
  this, I always enjoy exploring the language. The Emacs/CL ecosystem is
  amazing as well.

  SLIME is indescribably good. 'Nuff said. As for the configuration, I set SBCL
  as my preferred Lisp, and tell SLIME to look fancy. In addition, I tell SLIME
  where to find the Common Lisp Hyperspec so I can look up HTML documentation
  on the fly.

  #+BEGIN_SRC emacs-lisp :noweb-ref slime
    (quse-package slime
                  :init
                  (setf inferior-lisp-program "sbcl")
                  (setf common-lisp-hyperspec-root (getenv "HYPERSPEC_ROOT"))
                  (setf slime-contribs '(slime-fancy))
                  (slime-setup))
  #+END_SRC

  Integrating Auto-Complete and SLIME is painless, thanks to the work of Steve
  Purcell.

  #+BEGIN_SRC emacs-lisp :noweb-ref ac-slime
    (quse-package ac-slime
                  :init
                  (add-hook 'slime-mode-hook 'set-up-slime-ac)
                  (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
                  (eval-after-load "auto-complete"
                    '(add-to-list 'ac-modes 'slime-repl-mode)))
  #+END_SRC

* Edit web applications.

  Managing modes to edit the dozens of new file formats for a new web project
  every month is a nightmare. So much so I don't like to talk about it. I've
  found that =web-mode.el= does a pretty good job of managing them
  automagically. I use the version from which I sometimes submit pull
  requests. Setting ~web-mode-enable-engine-detection~ allows the mode to pick
  up on ~-*-~-style comments at the top of files.

  #+BEGIN_SRC emacs-lisp :noweb-ref web-mode
    (quse-package web-mode
                  :init
                  (setf web-mode-enable-engine-detection t)
                  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
                  (add-to-list 'org-src-lang-modes '("html" . web))
                  (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
                  (add-to-list 'org-src-lang-modes '("css" . web))
                  (add-to-list 'auto-mode-alist '("\\.js\\'" . web-mode))
                  (add-to-list 'auto-mode-alist '("\\.json\\'" . web-mode))
                  (add-to-list 'org-src-lang-modes '("js" . web))
                  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
                  (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode)))
  #+END_SRC

  =web-mode= takes care of Javascript, but isn't able to provide a full set of
  completion features for the language. Tern is a widely-used and featureful JS
  completion framework. It is easily installable on Emacs and can be forced to
  work with =web-mode= by modifying a few hooks and forcing some special files
  to be opened in JSON mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref tern
    (quse-package tern
                  :config
                  (setf tern-command '("tern"))
                  (add-hook 'web-mode-hook 'tern-mode)
                  (add-to-list 'auto-mode-alist '(".tern-project" . web-mode))
                  (add-to-list 'web-mode-content-types '("json" . ".tern-project")))
    (quse-package tern-auto-complete :config (tern-ac-setup))
  #+END_SRC

** Edit CoffeeScript (maybe).

   CoffeeScript is a light version of Javascript inspired by Python's syntax,
   which makes me like it automatically. In addition, a further variation,
   IcedCoffeeScript, makes a point of using continuation-passing style, which I
   find really fun to think about, especially in JavaScript. I may never end up
   using either for serious work, but just in case here's the mode
   installation.

   #+BEGIN_SRC emacs-lisp :noweb-ref coffee-mode
     (quse-package coffee-mode)
   #+END_SRC

* Steal Java-editing features from Eclipse.

  Trying to edit Java with just Emacs is a nightmare. I tried it for a while,
  but eventually caved into practicality and installed Eclipse, eclim, and
  =emacs-eclim=. The trio of software packages work together to use Eclipse's
  editing features and completion in Emacs. The configuration here comes
  straight from the =emacs-eclim= website, converted to a slightly strange form
  because of the project's package structure.

  #+BEGIN_SRC emacs-lisp :noweb-ref emacs-eclim
    (quelpa 'emacs-eclim)
    (use-package eclim :config (global-eclim-mode))
    (use-package eclimd :config (setf eclimd-wait-for-process nil))
    (use-package ac-emacs-eclim-source :config (ac-emacs-eclim-config))
  #+END_SRC

** Include YASnippet.

   Some features of =emacs-eclim= depend on having YASnippet, a popular Emacs
   snippet package, installed. I don't use YASnippet directly, only through
   =emacs-eclim=, but I may change my mind in the future.

   #+BEGIN_SRC emacs-lisp :noweb-ref yasnippet
     (quse-package yasnippet)
   #+END_SRC

* Edit and complete Nim.

  Nim is a systems programming languages that compiles to C, C++, ObjC, and
  JavaScript. It's the latest toy language I am trying to learn.

  #+BEGIN_SRC emacs-lisp :noweb-ref nim-mode
    (quse-package nim-mode)
  #+END_SRC

* View Markdown.

  I prefer Org to Markdown in every situation, but sometimes it is necessary to
  be able to read Markdown. Good thing there's a mode on MELPA!

  #+BEGIN_SRC emacs-lisp :noweb-ref markdown-mode
    (quse-package markdown-mode)
  #+END_SRC

* Edit and complete Go.

  I have fun with Go, and it's as simple as that :-). Its tooling for Emacs
  follows the theme of the rest of the tooling I use: It's simple and easy to
  install.

  #+BEGIN_SRC emacs-lisp :noweb-ref go-mode
    (quse-package go-mode
                  :init
                  (add-hook 'before-save-hook #'gofmt-before-save)
                  :bind (:map go-mode-map
                              ("M-." . godef-jump)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :noweb-ref go-autocomplete
    (quse-package go-autocomplete)
  #+END_SRC

* Edit Protocol Buffer files.

  Google's Protocol Buffers are a data exchange format useful for quick
  over-the-wire messages. The canonical implementation comes with a major mode
  for editing a Protocol Buffer definition.

  #+BEGIN_SRC emacs-lisp :noweb-ref protobuf-mode
    (quse-package (protobuf-mode :fetcher github
                                 :repo "google/protobuf"
                                 :files ("editors/protobuf-mode.el")))
  #+END_SRC

* YAML.

  "Yet Another Markup Language" indeed. It's the wrong acronym. Sue me. Ugh.

  #+BEGIN_SRC emacs-lisp :noweb-ref yaml-mode
    (quse-package yaml-mode)
  #+END_SRC

* Edit and complete Python.

  There are quite a few options for this in Emacs. The one I have found to be
  the most useful personally is Jedi, which is relatively minimal as full
  language environments go. It hooks up to a Python component which must be
  installed separately. The following snippet is the minimal Jedi setup taken
  from Jedi's own documentation. I choose to override Emacs jump-to shortcuts
  with Jedi's.

  #+BEGIN_SRC emacs-lisp :noweb-ref jedi
    (quse-package jedi
                  :init
                  (add-hook 'python-mode-hook 'jedi:setup)
                  (setf jedi:complete-on-dot t)
                  (setf jedi:use-shortcuts t))
  #+END_SRC

  Unfortunately, Jedi does not handle virtual environments by itself, so we
  need to install and configure the =virtualenvwrapper.el= package for
  everything to work properly.

  #+BEGIN_SRC emacs-lisp :noweb-ref virtualenvwrapper
    (quse-package virtualenvwrapper
                  :init
                  (venv-initialize-interactive-shells)
                  (venv-initialize-eshell))
  #+END_SRC

  Unfortunatelier, =virtualenvwrapper.el= seems to not respect the global
  "directory for virtualenvs" setting, while Jedi does. They end up being in
  different places. Ostensibly, the default for =virtualenvwrapper.el= is
  =~/.virtualenvs=, but since I've been bitten enough by edge cases around
  virtualenvs already, I set both variables here. Worse still, this block has
  to go before both of the preceding snippets to work properly. There has to be
  a way to do this with ~use-package~, but w/e I'm running on 0 sleep.

  #+BEGIN_SRC emacs-lisp :noweb-ref venv-location
    (let ((global-venv-location "~/.virtualenvs"))
      (setf python-environment-directory global-venv-location)
      (setf venv-location global-venv-location))
  #+END_SRC

* Edit Hoon files.

  Hoon is a somewhat esoteric programming language created and used on the
  functional Urbit operating system. The Urbit distribution contains an Emacs
  mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref hoon-mode
    (quse-package (hoon-mode :fetcher github
                             :repo "urbit/urbit"
                             :files ("extras/hoon-mode.el/hoon-mode.el")))
  #+END_SRC

* Edit GDScript files.

  The Godot game engine uses a Python-like scripting language. Their built-in
  editor is not the greatest, so why not use Emacs to edit scripts instead?

  #+BEGIN_SRC emacs-lisp :noweb-ref gdscript-mode
    (quse-package (gdscript-mode :fetcher github
                                 :repo "akoaysigod/gdscript-mode"))
  #+END_SRC

* Create and control Docker containers.

  Short and uninsteresting story: I used to shun containers, thinking that they
  were just a passing trend. I may be wrong, but using them changed my
  mind. Two packages, Spotify's =dockerfile-mode= and Silex's =docker.el=,
  allow Emacs to edit Dockerfiles and control docker operations, respectively.

  #+BEGIN_SRC emacs-lisp :noweb-ref docker
    (quse-package dockerfile-mode :init (add-to-list
                                         'auto-mode-alist
                                         '("Dockerfile\\'" . dockerfile-mode)))

    (quse-package docker :init (docker-global-mode))
  #+END_SRC

* Make Emacs and .NET cooperate.

  There is a complete and up-to-date major mode for C#, the only the .NET
  language I use at the moment, on MELPA.

  #+BEGIN_SRC emacs-lisp :noweb-ref csharp-mode
    (quse-package csharp-mode)
  #+END_SRC

  OmniSharp is a project which provides integration with .NET's introspection
  libraries to tools other than Visual Studio. I've had a lot of problems
  installing the server component, but the Emacs mode is easy to install and
  add to the C# mode's hook.

  #+BEGIN_SRC emacs-lisp :noweb-ref omnisharp
    (quse-package omnisharp :init (add-hook 'csharp-mode-hook 'omnisharp-mode))
  #+END_SRC

* Edit Lua.

  Lua-mode is a simple major mode for the Lua programming language which
  includes, highlighting, indentation, and send-to-REPL.

  #+BEGIN_SRC emacs-lisp :noweb-ref lua-mode
    (quse-package lua-mode)
  #+END_SRC

* Tangle source code.

  All files get tangled to the directory that this file is in.

** =init.el=

   #+BEGIN_SRC emacs-lisp :tangle init.el
     <<quelpa>>

     <<use-package>>

     <<quse-package>>

     <<better-defaults>>

     <<save-place-mode>>

     <<ido-really-everywhere>>

     <<fill-column>>

     <<prefer-coding-system>>

     <<inhibit-splash-screen>>

     <<undo-tree>>

     <<powerline>>

     <<moe-theme>>

     <<face-attribute-font>>

     <<smartparens>>

     <<dired-dwim-target>>

     <<org>>

     <<ox-reveal>>

     <<org-pdf-latexmk>>

     <<org-latex-classes-apa6>>

     <<ledger-mode>>

     <<password-store>>

     <<projectile>>

     <<magit>>

     <<ssh-agency>>

     <<auto-complete>>

     <<cider>>

     <<ac-cider>>

     <<slime>>

     <<ac-slime>>

     <<web-mode>>

     <<tern>>

     <<coffee-mode>>

     <<emacs-eclim>>

     <<yasnippet>>

     <<nim-mode>>

     <<markdown-mode>>

     <<go-mode>>

     <<go-autocomplete>>

     <<protobuf-mode>>

     <<yaml-mode>>

     <<venv-location>>

     <<jedi>>

     <<virtualenvwrapper>>

     <<hoon-mode>>

     <<gdscript-mode>>

     <<docker>>

     <<csharp-mode>>

     <<omnisharp>>

     <<lua-mode>>
   #+END_SRC
