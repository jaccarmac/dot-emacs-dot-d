#+TITLE: =.emacs.d=
#+AUTHOR: Jacob MacDonald
#+PROPERTY: header-args :noweb yes :padline no

#+BEGIN_SRC text :tangle UNLICENSE
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
  software, either in source code form or as a compiled binary, for any purpose,
  commercial or non-commercial, and by any means.

  In jurisdictions that recognize copyright laws, the author or authors of this
  software dedicate any and all copyright interest in the software to the public
  domain. We make this dedication for the benefit of the public at large and to
  the detriment of our heirs and successors. We intend this dedication to be an
  overt act of relinquishment in perpetuity of all present and future rights to
  this software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
  AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
#+END_SRC

Emacs is by far the most important application I use to develop. It is also the
most fun to configure application I use, period. That means configuring it can
be a daunting task. This document is my attempt to create an Emacs setup that
is comprehensive and easy to extend. To this end, I've made it a literate Org
file, which means it is organized, easy to modify, and easily convertible to
web page. It is also version controlled.

Now, for some code.

* Bootstrap.

  To load various packages and initialize them succinctly, I use =quelpa= and
  =use-package=. =quelpa= builds packages from source so I can stay on the
  bleeding edge. =use-package= loads and initializes the packages in a compact
  and readable macro. Unfortunately, one cannot load those packages using
  them. Fortunately, the bootstrapping process is relatively painless.

  The =quelpa= bootstrap snippet comes straight from the project's GitHub
  page. I use the non-auto-updating version.

  Unfortunately, the package has started to bitrot with regard to the
  =package-build= embedding/dependency. I'm patching the affected functions
  with advice and adding sourcehut support, but probably need to start moving
  away from this style of package management.

  #+BEGIN_SRC emacs-lisp :noweb-ref quelpa
    (eval-and-compile
      (package-initialize)
      (setf quelpa-update-melpa-p nil)
      (unless (package-installed-p 'quelpa)
        (with-temp-buffer
          (url-insert-file-contents
           "https://github.com/quelpa/quelpa/raw/master/quelpa.el")
          (eval-buffer)
          (quelpa-self-upgrade)))
      (add-to-list 'package-selected-packages 'quelpa))
  #+END_SRC

  Because of the last snippet, =use-package= can be downloaded using the
  =quelpa= function, but it must be loaded manually. (Manually being a
  one-liner. :-)

  #+BEGIN_SRC emacs-lisp :noweb-ref use-package
    (eval-when-compile
      (quelpa 'use-package)
      (require 'use-package))
    (add-to-list 'package-selected-packages 'use-package)
  #+END_SRC

  After the actual boostrapping I can use a small convenience macro I wrote
  myself to combine =quelpa= and =use-package=. It is called =quse-package= and
  is fetched via (you guessed it) =quelpa=.

  #+BEGIN_SRC emacs-lisp :noweb-ref quse-package
    (eval-when-compile
      (quelpa '(quse-package :fetcher github :repo "jaccarmac/quse-package"))
      (require 'quse-package))
    (add-to-list 'package-selected-packages 'quse-package)
  #+END_SRC

  Here's a very simple function to upgrade/clean out packages. This will also
  nuke the settings in =custom-file=. It combines features from =quelpa= and
  those built into Emacs.

  #+BEGIN_SRC emacs-lisp :noweb-ref upgrade-and-clean-packages
    (defun upgrade-and-clean-packages ()
      (interactive)
      (quelpa-upgrade-all)
      (package-autoremove)
      (customize-save-variable 'package-selected-packages nil))
  #+END_SRC

* Improve Emacs' interface.

  Vanilla Emacs is usable, but not usable enough to allow me to be
  productive. A few small packages allow me to actually function in the editor.

  Phil Hagelberg's =better-defaults= is a good start, including several
  one-line configuration options and usability rebinds.

  #+BEGIN_SRC emacs-lisp :noweb-ref better-defaults
    (quse-package better-defaults)
  #+END_SRC

  I like Emacs to start up in a predictable place. This ensures that
  =default-directory= is reasonable even if the Emacs daemon is started out of
  =$HOME=, perhaps in a project's repository to start a commit message.

  #+BEGIN_SRC emacs-lisp :noweb-ref default-directory
    (setf default-directory "~")
  #+END_SRC

  Emacs recently changed the way it handles saving the position of the point in
  visited files. =better-defaults= uses the old way (setting a variable) while
  newer versions of Emacs use a mode for the same behavior. I'm almost ready to
  submit a pull request to =better-defaults=, but don't understand the nuts and
  bolts of the change completely. Thus, here is a monkey-patch to fix the
  behavior for myself.

  #+BEGIN_SRC emacs-lisp :noweb-ref save-place-mode
    (use-package saveplace
      :init
      (when (fboundp 'save-place-mode) (save-place-mode)))
  #+END_SRC

  And while =better-defaults= enables Ido mode and Ido flex matching, both of
  which are very useful settings, it does not enable Ido everyhwere, which is
  very useful. Fully converting Emacs to use Ido has to be done in several
  steps. First comes the basic Ido setup included in =better-defaults=. Then,
  ~ido-ubiquitous~, a slightly more dangerous built-in function, is
  activated. Finally, several more packages are used to fill in the
  gaps. Namely, they are =ido-ubiquitous= for a few edge cases, =smex= to
  replace the =M-x= prompt, =ido-yes-or-no= to replace binary prompts, and
  =crm-custom.el= to replace =completing-read-multiple=.

  #+BEGIN_SRC emacs-lisp :noweb-ref ido-really-everywhere
    (declare-function ido-everywhere "ido")
    (ido-everywhere)
    (setf ido-auto-merge-work-directories-length -1)

    (quse-package ido-completing-read+
      :preface
      (defvar org-completion-use-ido)
      (defvar magit-completing-read-function)
      :init
      (ido-ubiquitous-mode)
      (setf org-completion-use-ido t)
      (setf magit-completing-read-function 'magit-ido-completing-read))

    (quse-package ido-yes-or-no :init (ido-yes-or-no-mode))

    (quse-package crm-custom :init (crm-custom-mode))

    (quse-package smex
      :init (smex-initialize)
      :bind (("M-x" . smex)
             ("M-X" . smex-major-mode-commands)
             ("C-c C-c M-x" . execute-extended-command)))
  #+END_SRC

  On top of the sensible settings in =better-defaults=, I like to set
  =fill-column= to a sane value that doesn't depend on Emacs' frame
  size.

  #+BEGIN_SRC emacs-lisp :noweb-ref fill-column
    (setq-default fill-column 79)
  #+END_SRC

  Unix UTF-8 encoding is a better sensible default for encoding than whatever
  platform-dependent value Emacs uses by default.

  #+BEGIN_SRC emacs-lisp :noweb-ref prefer-coding-system
    (prefer-coding-system 'utf-8-unix)
  #+END_SRC

  It's also nice to not have to deal with the splash screen every time Emacs
  starts.

  #+BEGIN_SRC emacs-lisp :noweb-ref inhibit-splash-screen
    (setq-default inhibit-splash-screen t)
  #+END_SRC

  Exposing Emacs' multi-branch undo and redo feature graphically is
  fantastically useful. Tony Cubitt's =undo-tree-mode= does just that.

  TODO =undo-tree= has started to get really slow. None of the solutions I've
  found online seem to help, as it seems unrelated to corrupt history. Lazy
  drawing is enabled, undo-in-region is disabled... Profiling tells me
  little. ~line-number-at-pos~ in ~undo-tree-move-down~ eats a lot of CPU
  time. The author wrote a [[https://www.dr-qubit.org/Lost_undo-tree_history.html][blog post]] which is at least worth reading.

  There is a problem in the definition of ~undo-tree-switch-branch~. It pulls
  data from ~prefix-arg~, when ~current-prefix-arg~ is the correct place to
  check. I'm not sure why its ~interactive~ doesn't use a string, but that
  change is enough to allow use of the undo tree without the visualization.

  #+BEGIN_SRC emacs-lisp :noweb-ref undo-tree
    (quse-package (undo-tree :fetcher gitlab
                             :repo "tsc25/undo-tree")
      :init
      (global-undo-tree-mode)
      (setf undo-tree-history-directory-alist
            `((".". ,(concat user-emacs-directory "undo-tree-history")))))
  #+END_SRC

  Donald Ephraim Curtis had made a great port of Vim Powerline. It is helpful
  for keeping track of location in a file, and it looks pretty.

  #+BEGIN_SRC emacs-lisp :noweb-ref powerline
    (quse-package powerline :init (powerline-default-theme))
  #+END_SRC


  kuanyui's =moe-theme= is a perennial favoritedue to its amount of contrast
  and variety of faces.

  #+BEGIN_SRC emacs-lisp :noweb-ref moe-theme
    (quse-package moe-theme :config (load-theme 'moe-dark t))
  #+END_SRC

  That said, after discovering steckerhalter's Grand Shell recently I became
  partial to and used it for a while.

  #+BEGIN_SRC emacs-lisp :noweb-ref grandshell-theme
    (quse-package grandshell-theme :config (load-theme 'grandshell t))
  #+END_SRC

  Even more recently, I've decided that this Material Design-based theme is
  pretty nice.

  #+BEGIN_SRC emacs-lisp :noweb-ref material-theme
    (quse-package material-theme :config (load-theme 'material t))
  #+END_SRC

  One of those themes will likely be used. No promises on which one, and it
  changes pretty often!

  On top of the color themes themselves, I find it useful to add even more
  shiny colors. The best way to do this when lots of Lisp is being edited is,
  without a doubt, rainbow delimiters.

  #+BEGIN_SRC emacs-lisp :noweb-ref rainbow-delimiters
    (quse-package rainbow-delimiters)
  #+END_SRC

  I also enjoy using a pleasant monospace font. It's pretty easy to get Emacs
  to recognize your global GTK settings on a Linux box, but for Windows
  machines the font needs to be set programmatically or in the registry. I
  explicitly use a chosen font it it's installed installed, and defaults back
  to the font provided by the system if the font I want isn't there.

  I like finding new fonts; The one below is an interesting one, probably from
  the set below:

  * Iosevka
  * Go Mono
  * Unscii

  #+BEGIN_SRC emacs-lisp :noweb-ref face-attribute-font
    (push '(font . "JuliaMono 11") default-frame-alist)
  #+END_SRC

  Emoji look like garbage by default, so I use the =emojify= package to insert
  nice images in their place.

  #+BEGIN_SRC emacs-lisp :noweb-ref emojify
    (quse-package emojify :hook (after-init . global-emojify-mode))
  #+END_SRC

  The =smartparens= package is like =paredit= plus a bunch of nice extras. I
  enable the strict mode globally and use the maintainer's default keybindings.

  #+BEGIN_SRC emacs-lisp :noweb-ref smartparens
    (quse-package smartparens
      :init
      (smartparens-global-mode)
      (smartparens-global-strict-mode)
      (require 'smartparens-config)
      (sp-use-smartparens-bindings))
  #+END_SRC

  I hate the way that playing with packages, among other things, dirties up my
  carefully (ha!) curated ~init.el~. Emacs allows you to customize the location
  of the so-called "custom file". I also don't care about any customize
  variables at the moment, so I won't even load it hehe.

  #+BEGIN_SRC emacs-lisp :noweb-ref custom-file
    (setf custom-file "~/.emacs.d/custom.el")
  #+END_SRC

  Speaking of that file, in =quse-package= and a few times in this file,
  =package-selected-packages= is changed without getting persisted. Let's fix
  that.

  #+BEGIN_SRC emacs-lisp :noweb-ref save-package-selected-packages
    (customize-save-variable 'package-selected-packages package-selected-packages)
  #+END_SRC

  Emacs can integrate with your system's trash so deletions are less
  permanent. A simple flag enables this feature.

  #+BEGIN_SRC emacs-lisp :noweb-ref delete-with-trash
    (setf delete-by-moving-to-trash t)
  #+END_SRC

* Make copying in Dired marginally better.

  `dired-dwim-target` makes Dired Do What I Mean when copying. This means I can
  open two Dired windows in disparate locations and copy files between them
  without having to edit long pathnames.

  #+BEGIN_SRC emacs-lisp :noweb-ref dired-dwim-target
    (setf dired-dwim-target t)
  #+END_SRC

* Install a recent version of Org mode.

  It works fine without installing the bleeding edge, but that's no fun. And
  installing the bleeding edge is just too easy...

  Org mode is so awesome that I use it as my default mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref org
    (quse-package (org :fetcher git
                       :url "https://git.savannah.gnu.org/git/emacs/org-mode"
                       :files ("lisp/*.el"
                               "contrib/lisp/*.el"
                               "doc/dir"
                               "doc/*.texi"))
      :init
      (setq-default major-mode 'org-mode)
      (use-package org-tempo))
  #+END_SRC

** Create presentations in Org.

   Org comes preloaded with facilities for Beamer export, which produces
   high-quality LaTeX presentations. I prefer something lighter and webbier,
   and that thing is reveal.js, which also has an Org exporter. However, this
   one needs to be installed.

   #+BEGIN_SRC emacs-lisp :noweb-ref ox-reveal
     (quse-package ox-reveal)
   #+END_SRC

** Improve Org's LaTeX export.

   I end up writing a lot of papers in Org and exporting via LaTeX for nice
   PDFs. After a few months of doing this with a more-or-less vanilla Org
   setup, I've found that doing citations properly is difficult. That is the
   motivation for the changes below, which consist of:

   1. Setting the export process to =latexmk=.

      #+BEGIN_SRC emacs-lisp :noweb-ref org-pdf-latexmk
        (setf org-latex-pdf-process (list "latexmk -f -pdf %f"))
      #+END_SRC

*** Allow APA-style export from Org.

    To use document classes that aren't ~article~, ~report~, or ~book~, the
    class needs to be registered in Org. I took the samples from the existing
    ~org-latex-classes~ and added one for the LaTeX ~apa6~ package.

    #+BEGIN_SRC emacs-lisp :noweb-ref org-latex-classes-apa6
      (add-to-list 'org-latex-classes
                   '("apa6"
                     "\\documentclass[man,12pt]{apa6}"
                     ("\\section{%s}" . "\\section*{%s}")
                     ("\\subsection{%s}" . "\\subsection*{%s}")
                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
    #+END_SRC

* Manage my money.

  Ledger is a fantastic personal accounting application. It has a ton of
  features, but it relatively easy to configure in plain text. It comes with an
  Emacs mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref ledger-mode
    (quse-package ledger-mode
      :init
      (add-to-list 'auto-mode-alist
                   '("ledger.dat" . ledger-mode))
      (add-hook 'ledger-mode-hook (lambda ()
                                    (setq-local tab-always-indent 'complete)
                                    (setq-local completion-cycle-threshold t)
                                    (setq-local ledger-complete-in-steps t))))
  #+END_SRC

* Generate and secure passwords.

  I use =password-store= to manage and generate all my passwords. This utility
  stores passwords in text files encrypted by my GPG key, and can copy them to
  the system clipboard when I need to use them. A work-in-progress Emacs mode
  is included in the distribution and cloned and installed in the following
  snippet.

  #+BEGIN_SRC emacs-lisp :noweb-ref password-store
    (quse-package password-store)
  #+END_SRC

* Manage projects.

  One-off-file hacking is great, but most of what I do is done in the context
  of a project, often one too big to fit inside my head. The following packages
  integrate tools that do the legwork of project management with Emacs.

  Bozhidar Batsov's =projectile= is an all-inclusive project management
  navigator and indexer for Emacs. The indexing it does is especially useful,
  letting you grep an entire project with a simple key chord. I force the
  indexing to use fast Unix-y tools even on Windows. Even though this method is
  faster than using Emacs Lisp indexing, note that it requires extra tools,
  namely Git and =find=, to be installed.

  #+BEGIN_SRC emacs-lisp :noweb-ref projectile
    (quse-package projectile
      :init
      (projectile-mode)
      (setf projectile-switch-project-action 'projectile-dired)
      (setf projectile-indexing-method 'alien)
      :bind
      (("C-c p" . projectile-command-map)))
  #+END_SRC

  Git is the modern king of version control. The Magit project turns Emacs into
  an extremely powerful interface to it. I find that key chords are much more
  efficient than terminal commands after a few days' practice.

  #+BEGIN_SRC emacs-lisp :noweb-ref magit
    (quse-package magit)
  #+END_SRC

Magit's interface to the GitHubs and GitLabs of the world ("forges"), is
seemingly useful and not half as difficult to set up as advertised.

It does require compilation of a SQL library and is not as polite as
=pdf-tools= (starts the process without asking). A similar Guix profile is
probably in order but not documented here yet.

#+begin_src emacs-lisp :noweb-ref forge
  (quse-package forge)
#+end_src

  Using SSH Git remotes on Windows is a nightmare due to how difficult it is to
  get ssh-agent's environment variables into an Emacs not started in Cygwin or
  MSYS. Thankfully, the Magit maintainers have written a package to manage said
  environment variables, just for Emacs, automatically!

  #+BEGIN_SRC emacs-lisp :noweb-ref ssh-agency
    (quse-package ssh-agency)
  #+END_SRC

  Some projects use EditorConfig to manage style settings, etc.

  #+BEGIN_SRC emacs-lisp :noweb-ref editorconfig
    (quse-package editorconfig :config (editorconfig-mode 1))
  #+END_SRC

  Dired, powerful as it is, is sometimes bad about showing the structure of a
  deeply nested set of directories. Direx is a tree-based file browser. While
  it isn't as powerful as Dired, it's useful to have around. The relevant
  interactive function is =direx:find-directory=. (=direx:jump-to-directory= is
  a shortcut to view the current directory.)

  #+BEGIN_SRC emacs-lisp :noweb-ref direx
    (quse-package direx)
  #+END_SRC

  I started using =direnv= and realized instantly how powerful it is,
  especially combined with Guix and a little bit of shell scripting. The
  per-buffer approach to adding it to Emacs adds a little bit of latency, which
  I'm not thrilled with. But other than that it works like a charm. This
  snippet gets put at the very end of the init file, for reasons detailed on
  =envrc='s GitHub page.

  #+begin_src emacs-lisp :noweb-ref envrc
    (quse-package envrc :init (envrc-global-mode))
  #+end_src
* Complete symbols.

  It's nearly impossible to work with large projects or avoid misspellings
  without a good, always-accessible completion framework. The Emacs community
  is split between using Company and Auto-Complete. I've used Auto-Complete for
  quite a while and have no pressing reason to switch. Its initialization is
  rather simple; Sources are initialized later with the modes they are
  associated with.

  #+BEGIN_SRC emacs-lisp :noweb-ref auto-complete
    (quse-package auto-complete
      :init
      (require 'auto-complete-config)
      (ac-config-default))
  #+END_SRC

  A few modes (see [[*Edit and complete Nim.][my Nim configuration]] for example) create hooks on
  ~completion-at-point-function~ instead of hooking into a dedicated external
  completion package. To pulll these completions into Auto-Complete's list, we
  set up ~ac-capf~. It is activated in the relevant modes' setups.

  #+BEGIN_SRC emacs-lisp :noweb-ref ac-capf
    (quse-package ac-capf)
  #+END_SRC

* Clojure.

  Clojure is a fantastic Lisp that gives me access to the JVM without having to
  deal with Java.

  CIDER is, in my opinion, the best way to edit Clojure in Emacs, bar
  none. Loading is done in the standard quelpa way; The configuration options
  are taken from CIDER's GitHub page and its first-boot help screen. I prefer
  Boot over Leiningen, so I set Boot as my default REPL. I also set up a file
  to store REPL history, which allows me to recall stuff to the REPL across
  sessions. The mentioned first-boot screen is disabled.

  #+BEGIN_SRC emacs-lisp :noweb-ref cider
    (quse-package cider
      :init
      (setf cider-repl-tab-command 'indent-for-tab-command)
      (setf cider-jack-in-default 'boot)
      (setf cider-repl-history-file "~/.cider-repl-history")
      (setf cider-repl-display-help-banner nil))
  #+END_SRC

  CIDER can be integrated with Auto-Complete painlessly by using the ac-cider
  package.

  #+BEGIN_SRC emacs-lisp :noweb-ref ac-cider
    (quse-package ac-cider
      :init
      (add-hook 'cider-mode-hook 'ac-cider-setup)
      (add-hook 'cider-mode-hook 'ac-flyspell-workaround)
      (add-hook 'cider-repl-mode-hook 'ac-cider-setup)
      (add-hook 'cider-repl-mode-hook 'ac-flyspell-workaround)
      (add-hook 'cider-clojure-interaction-mode-hook 'ac-cider-setup)
      (add-hook 'cider-clojure-interaction-mode-hook 'ac-flyspell-workaround)
      (eval-after-load "auto-complete"
        '(progn
           (add-to-list 'ac-modes 'cider-mode)
           (add-to-list 'ac-modes 'cider-repl-mode)
           (add-to-list 'ac-modes 'cider-clojure-interaction-mode))))
  #+END_SRC

* Hack with Common Lisp.

  While most of my Lisp-writing has been in Clojure, the majority of my
  Lisp-learning has been in Common Lisp. Fanboys say there's nothing you can't
  do with CL, and, while I don't have enough experience to confirm or deny
  this, I always enjoy exploring the language. The Emacs/CL ecosystem is
  amazing as well.

  SLIME is indescribably good. 'Nuff said. As for the configuration, I set SBCL
  as my preferred Lisp, and tell SLIME to look fancy. In addition, I tell SLIME
  where to find the Common Lisp Hyperspec so I can look up HTML documentation
  on the fly.

  #+BEGIN_SRC emacs-lisp :noweb-ref slime
    (quse-package slime
      :init
      (setf slime-lisp-implementations '((sbcl ("guix" "shell" "sbcl" "--" "sbcl"))
                                         (ccl ("guix" "shell" "ccl" "--" "ccl"))
                                         (abcl ("guix" "shell" "abcl" "--" "abcl"))
                                         (ecl ("guix" "shell" "ecl" "--" "ecl"))))
      (setf common-lisp-hyperspec-root (getenv "HYPERSPEC_ROOT"))
      (setf slime-contribs '(slime-fancy))
      (slime-setup))
  #+END_SRC

  Integrating Auto-Complete and SLIME is painless, thanks to the work of Steve
  Purcell.

  #+BEGIN_SRC emacs-lisp :noweb-ref ac-slime
    (quse-package ac-slime
      :init
      (add-hook 'slime-mode-hook 'set-up-slime-ac)
      (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
      (eval-after-load "auto-complete"
        '(add-to-list 'ac-modes 'slime-repl-mode)))
  #+END_SRC

* Edit web applications.

  Managing modes to edit the dozens of new file formats for a new web project
  every month is a nightmare. So much so I don't like to talk about it. I've
  found that =web-mode.el= does a pretty good job of managing them
  automagically. I use the version from which I sometimes submit pull
  requests. Setting ~web-mode-enable-engine-detection~ allows the mode to pick
  up on ~-*-~-style comments at the top of files.

  #+BEGIN_SRC emacs-lisp :noweb-ref web-mode
    (quse-package web-mode
      :init
      (setf web-mode-enable-engine-detection t)
      (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
      (add-to-list 'org-src-lang-modes '("html" . web))
      (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
      (add-to-list 'org-src-lang-modes '("css" . web))
      (add-to-list 'auto-mode-alist '("\\.js\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.json\\'" . web-mode))
      (add-to-list 'org-src-lang-modes '("js" . web))
      (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.jsx\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.ts\\'" . web-mode)))
  #+END_SRC

  =web-mode= takes care of Javascript, but isn't able to provide a full set of
  completion features for the language. Tern is a widely-used and featureful JS
  completion framework. It is easily installable on Emacs and can be forced to
  work with =web-mode= by modifying a few hooks and forcing some special files
  to be opened in JSON mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref tern
    (quse-package tern
      :config
      (setf tern-command '("tern"))
      (add-hook 'web-mode-hook 'tern-mode)
      (add-to-list 'auto-mode-alist '(".tern-project" . web-mode))
      (add-to-list 'web-mode-content-types '("json" . ".tern-project")))
    (quse-package tern-auto-complete :config (tern-ac-setup))
  #+END_SRC

** Edit CoffeeScript (maybe).

   CoffeeScript is a light version of Javascript inspired by Python's syntax,
   which makes me like it automatically. In addition, a further variation,
   IcedCoffeeScript, makes a point of using continuation-passing style, which I
   find really fun to think about, especially in JavaScript. I may never end up
   using either for serious work, but just in case here's the mode
   installation.

   #+BEGIN_SRC emacs-lisp :noweb-ref coffee-mode
     (quse-package coffee-mode)
   #+END_SRC

* Steal Java-editing features from Eclipse.

  Trying to edit Java with just Emacs is a nightmare. I tried it for a while,
  but eventually caved into practicality and installed Eclipse, eclim, and
  =emacs-eclim=. The trio of software packages work together to use Eclipse's
  editing features and completion in Emacs. The configuration here comes
  straight from the =emacs-eclim= website, converted to a slightly strange form
  because of the project's package structure.

  #+BEGIN_SRC emacs-lisp :noweb-ref emacs-eclim
    (quelpa 'eclim)
    (add-to-list 'package-selected-packages 'eclim)
    (use-package eclim :config (global-eclim-mode))
    (use-package eclimd :config (setf eclimd-wait-for-process nil))
    (quse-package ac-emacs-eclim :config (ac-emacs-eclim-config))
  #+END_SRC

** Include YASnippet.

   Some features of =emacs-eclim= depend on having YASnippet, a popular Emacs
   snippet package, installed. I don't use YASnippet directly, only through
   =emacs-eclim=, but I may change my mind in the future.

   #+BEGIN_SRC emacs-lisp :noweb-ref yasnippet
     (quse-package yasnippet)
   #+END_SRC

* Edit and complete Nim.

  Nim is a systems programming languages that compiles to C, C++, ObjC, and
  JavaScript. It's the latest toy language I am trying to learn. Nim's Emacs
  mode adds some completion information to ~completion-at-point-function~. Here
  the completion daemon is configured and ~ac-capf~ is setup in the relevant
  modes.

  #+BEGIN_SRC emacs-lisp :noweb-ref nim-mode
    (quse-package nim-mode)
  #+END_SRC

* View Markdown.

  I prefer Org to Markdown in every situation, but sometimes it is necessary to
  be able to read Markdown. Good thing there's a mode on MELPA!

  #+BEGIN_SRC emacs-lisp :noweb-ref markdown-mode
    (quse-package markdown-mode)
  #+END_SRC

* Edit and complete Go.

  I have fun with Go, and it's as simple as that :-). Its tooling for Emacs
  follows the theme of the rest of the tooling I use: It's simple and easy to
  install.

  #+BEGIN_SRC emacs-lisp :noweb-ref go-mode
    (quse-package go-mode
      :init
      (when (executable-find "goimports")
        (setf gofmt-command "goimports"))
      (add-hook 'before-save-hook #'gofmt-before-save)
      :bind (:map go-mode-map
                  ("M-." . godef-jump)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :noweb-ref go-autocomplete
    (quse-package go-autocomplete)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :noweb-ref go-guru
    (quse-package go-guru)
  #+END_SRC

* Edit Protocol Buffer files.

  Google's Protocol Buffers are a data exchange format useful for quick
  over-the-wire messages. The canonical implementation comes with a major mode
  for editing a Protocol Buffer definition.

  #+BEGIN_SRC emacs-lisp :noweb-ref protobuf-mode
    (quse-package (protobuf-mode :fetcher github
                                 :repo "google/protobuf"
                                 :files ("editors/protobuf-mode.el")))
  #+END_SRC

* YAML.

  "Yet Another Markup Language" indeed. It's the wrong acronym. Sue me. Ugh.

  #+BEGIN_SRC emacs-lisp :noweb-ref yaml-mode
    (quse-package yaml-mode)
  #+END_SRC

* Edit and complete Python.

  There are quite a few options for this in Emacs. The one I have found to be
  the most useful personally is Jedi, which is relatively minimal as full
  language environments go. It hooks up to a Python component which must be
  installed separately. The following snippet is the minimal Jedi setup taken
  from Jedi's own documentation. I choose to override Emacs jump-to shortcuts
  with Jedi's.

  #+BEGIN_SRC emacs-lisp :noweb-ref jedi
    (quse-package jedi
      :init
      (add-hook 'python-mode-hook 'jedi:setup)
      (setf jedi:complete-on-dot t)
      (setf jedi:use-shortcuts t))
  #+END_SRC

  Unfortunately, Jedi does not handle virtual environments by itself, so we
  need to install and configure the =virtualenvwrapper.el= package for
  everything to work properly.

  #+BEGIN_SRC emacs-lisp :noweb-ref virtualenvwrapper
    (quse-package virtualenvwrapper
      :preface
      (defvar python-environment-directory)
      (defvar venv-location)
      :init
      (venv-initialize-interactive-shells)
      (venv-initialize-eshell)
      (let ((global-venv-location "~/.virtualenvs"))
        (setf python-environment-directory global-venv-location)
        (setf venv-location global-venv-location)))
  #+END_SRC

  Unfortunatelier, =virtualenvwrapper.el= seems to not respect the global
  "directory for virtualenvs" setting, while Jedi does. They end up being in
  different places. Ostensibly, the default for =virtualenvwrapper.el= is
  =~/.virtualenvs=, but since I've been bitten enough by edge cases around
  virtualenvs already, I set both variables here. Worse still, this block has
  to go before both of the preceding snippets to work properly. There has to be
  a way to do this with ~use-package~, but w/e I'm running on 0 sleep.

  #+BEGIN_SRC emacs-lisp :noweb-ref venv-location
    (let ((global-venv-location "~/.virtualenvs"))
      (setf python-environment-directory global-venv-location)
      (setf venv-location global-venv-location))
  #+END_SRC

* Edit Hoon files.

  Hoon is a somewhat esoteric programming language created and used on the
  functional Urbit operating system. The Urbit distribution contains an Emacs
  mode.

  #+BEGIN_SRC emacs-lisp :noweb-ref hoon-mode
    (quse-package (hoon-mode :fetcher github :repo "urbit/hoon-mode.el" :files (:defaults "hoon-dictionary.json")))
  #+END_SRC

* Edit GDScript files.

  The Godot game engine uses a Python-like scripting language. Their built-in
  editor is not the greatest, so why not use Emacs to edit scripts instead?

  #+BEGIN_SRC emacs-lisp :noweb-ref gdscript-mode
    (quse-package (gdscript-mode :fetcher github
                                 :repo "jaccarmac/gdscript-mode"
                                 :branch "fix-line-endings"))
  #+END_SRC

* Create and control Docker containers.

  Short and uninsteresting story: I used to shun containers, thinking that they
  were just a passing trend. I may be wrong, but using them changed my
  mind. Two packages, Spotify's =dockerfile-mode= and Silex's =docker.el=,
  allow Emacs to edit Dockerfiles and control docker operations, respectively.

  Connecting to Docker over Tramp is useful, especially on Windows where it's
  not easy to run an Emacs session directly from the container. The package
  providing an appropriate Tramp method is =docker-tramp= and is a dependency
  of =docker.el=. The dependency is made explicit anyway.

  #+BEGIN_SRC emacs-lisp :noweb-ref docker
    (quse-package dockerfile-mode :init (add-to-list
                                         'auto-mode-alist
                                         '("Dockerfile\\'" . dockerfile-mode)))

    (quse-package docker)
  #+END_SRC

* Make Emacs and .NET cooperate.

  OmniSharp is a project which provides integration with .NET's introspection
  libraries to tools other than Visual Studio. I've had a lot of problems
  installing the server component, but the Emacs mode is easy to install and
  add to the C# mode's hook.

  Omnisharp breaks Emacs on Windows at the moment, a problem which is easily
  solved by using the HTTP bus which uses =request-deferred=.

  #+BEGIN_SRC emacs-lisp :noweb-ref omnisharp
    (quse-package request-deferred)
    (quse-package omnisharp
      :config
      (add-hook 'csharp-mode-hook 'omnisharp-mode))
  #+END_SRC

* Edit Lua.

  Lua-mode is a simple major mode for the Lua programming language which
  includes, highlighting, indentation, and send-to-REPL.

  #+BEGIN_SRC emacs-lisp :noweb-ref lua-mode
    (quse-package lua-mode)
  #+END_SRC

* Edit browser text fields from Emacs.

  It's quite a handy ability, and just requires starting a server when emacs
  does.

  #+BEGIN_SRC emacs-lisp :noweb-ref edit-server
    (quse-package edit-server
      :init (setf edit-server-new-frame nil)
      :config (edit-server-start))
  #+END_SRC

* Edit Erlang.

  Erlang comes with a mode that sets itself up pretty nicely.

  #+BEGIN_SRC emacs-lisp :noweb-ref erlang
    (quse-package erlang)
  #+END_SRC

* Edit Rust projects.

  Emacs has a mode for Rust.

  #+BEGIN_SRC emacs-lisp :noweb-ref rust-mode
    (quse-package rust-mode
      :init (setf rust-format-on-save t))
  #+END_SRC

  It has a minor mode which hooks up some keybinds in that mode to various
  Cargo commands.

  #+BEGIN_SRC emacs-lisp :noweb-ref cargo
    (quse-package cargo :init (add-hook 'rust-mode-hook 'cargo-minor-mode))
  #+END_SRC

  Emacs also has a mode for TOML files. This should /probably/ go in another
  section, but since I don't use it for anything other than =Cargo.toml= files,
  meh.

  #+BEGIN_SRC emacs-lisp :noweb-ref toml-mode
    (quse-package toml-mode)
  #+END_SRC

* Edit wikis.

  Wikipedia and workplace wikis are often-useful. There's a very nice MediaWiki
  integration package for Emacs. Eventually, I'd like to configure it to
  properly use external files for authentication. For right now, I just cobble
  together my creds in Customize every time I need to edit something. Consider
  it a TODO.

  #+BEGIN_SRC emacs-lisp :noweb-ref mediawiki
    (quse-package mediawiki)
  #+END_SRC

* TODO
https://www.gnu.org/software/hyperbole/

unicode-fonts by rolandwalker
persistent-soft also by him
eshell with cd
use portacle as example
easy way to use my forks temporarily
https://github.com/Fuco1/Elsa <--- dis cool
https://github.com/brotzeit/rustic <--- so dis

Nuke below warnings:
Error (use-package): docker/:init: Symbol’s function definition is void: docker-global-mode
Warning (emacs): [EXWM] EXWM fails to start (error: (Other window manager detected))
https://emacsredux.com/blog/2018/11/09/an-easy-kill/
https://www.reddit.com/r/emacs/comments/9vmljb/what_do_you_have_bound_to_mn_and_mp/e9dm9fc/

https://vxlabs.com/2018/11/19/configuring-emacs-lsp-mode-and-microsofts-visual-studio-code-python-language-server/
https://vxlabs.com/2018/06/08/python-language-server-with-emacs-and-lsp-mode/

https://www.reddit.com/r/emacs/comments/aazjl5/blog_how_im_failing_literate_config_in_emacs/

https://github.com/tttuuu888/.emacs.d/blob/master/install.el use this to do an initial install pass or some garbage idk

https://github.com/joaotavora/eglot other LSP
[[https://github.com/abo-abo/swiper]] completion alternative
https://github.com/leoliu/easy-kill
https://github.com/tarsius/hl-todo highlight TODO
https://github.com/bbatsov/crux maybe useful util collection

https://github.com/Kungsgeten/org-brain

emacs-libvterm

take hints from https://github.com/hardcoreplayers/Eva

Is [[https://countvajhula.com/2021/09/25/the-animated-guide-to-symex/][Symex]] better than Paredit/Smartparens?

[[https://github.com/MatthewZMD/.emacs.d][M-EMACS, a possibly faster distribution]]

[[https://shaunsingh.github.io/nix-darwin-dotfiles/][Shaun Singh's config, yet another possible template]].

[[https://github.com/daviwil/emacs-from-scratch][Something closer to an actual template]].
** [[https://www.emacswiki.org/emacs/Icicles][Icicles]]
*** [[https://www.reddit.com/r/emacs/comments/vr81n6/comment/ieu8d9q/][and minibuffer completion]]
** [[https://github.com/plexus/chemacs2][Chemacs2]]
It's at least useful to read to get a handle on the new init structure. Ideally
it will be good enough to incrementally approach a better config or better
~quse-package~.
** Profile startup.
An article about [[https://blog.d46.us/advanced-emacs-startup/][advanced techniques]] seems apropos.

[[https://github.com/jschaf/esup][ESUP]] chokes on the Zig mode and YASnippet. Making a few changes - variable at
the top and a couple explicit ~require~ calls - speeds things way up. It seems
that most of my startup sluggishness is due to activating global stuff and
loading Org. The latter issue can be fixed in a more or less elegant way:
~use-package~ dependency specification.

#+begin_src elisp
  ;;; -*- lexical-binding: t; -*-

  (setf use-package-always-defer t)
#+end_src

#+begin_src elisp
  (declare-function ido-everywhere "ido")
  (require 'ido)
  (ido-everywhere)
#+end_src

#+begin_src elisp
  (require 'ox-latex)
   (add-to-list 'org-latex-classes
#+end_src

I got further speedups by changing ~quse-package~ to ~use-package~, so it sure
looks like Quelpa is slowing my startup way down. Deferring everything makes
Emacs a little weird. Most of the weirdness seems to be fixed with well-placed
~:demand~ marks, but I imagine I should change ~quse-package~ to behave more
like ~quelpa-use-package~, avoiding anything Quelpa for as long as possible.
** Templating.
[[https://www.emacswiki.org/emacs/TempoMode][Tempo]] seems to be behind the Org Tempo stuff I enabled manually a while
back. There's an incremental improvement package which showed up on MELPA:
[[https://github.com/minad/tempel][TempEl]]. It may be worth checking out.
** [[https://www.reddit.com/r/unixporn/comments/s7p7pr/so_which_run_launcher_do_you_use_rofi_or_dmenu/][Emacs as a launcher]].
** [[https://xenodium.com/emacs-dwim-swiper-vs-isearch-vs-phi-search/][DWIM]]
* Tangle source code.

  All files get tangled to the directory that this file is in.

** =init.el=

   #+BEGIN_SRC emacs-lisp :tangle init.el
     ;;; -*- lexical-binding: t; -*-

     (defvar network-security-level)
     (setf network-security-level 'high)
     ;; bugfix for https://debbugs.gnu.org/cgi/bugreport.cgi?bug=34341
     (setf gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

     <<default-directory>>

     <<quelpa>>

     <<use-package>>

     <<quse-package>>

     (require 'bind-key)

     <<better-defaults>>

     (put 'narrow-to-region 'disabled nil)

     <<save-place-mode>>

     <<ido-really-everywhere>>

     <<fill-column>>

     <<prefer-coding-system>>

     <<inhibit-splash-screen>>

     <<undo-tree>>

     <<powerline>>

     (quse-package nord-theme
       :init
       (if (daemonp)
           (cl-labels ((load-nord (frame)
                         (with-selected-frame frame
                           (load-theme 'nord t))
                         (remove-hook
                          'after-make-frame-functions
                          #'load-nord)))
             (add-hook 'after-make-frame-functions #'load-nord))
         (load-theme 'nord t)))

     <<rainbow-delimiters>>

     <<face-attribute-font>>

     <<emojify>>

     <<smartparens>>

     <<custom-file>>

     <<upgrade-and-clean-packages>>

     <<delete-with-trash>>

     <<dired-dwim-target>>

     <<org>>

     (quse-package htmlize)

     <<ox-reveal>>

     <<org-pdf-latexmk>>

     <<org-latex-classes-apa6>>

     <<ledger-mode>>

     <<password-store>>

     <<projectile>>

     <<magit>>

     <<forge>>

     <<ssh-agency>>

     <<editorconfig>>

     <<direx>>

     <<auto-complete>>

     <<ac-capf>>

     <<cider>>

     <<slime>>

     <<ac-slime>>

     <<web-mode>>

     <<tern>>

     <<coffee-mode>>

     <<yasnippet>>

     <<nim-mode>>

     <<markdown-mode>>

     <<go-mode>>

     <<go-autocomplete>>

     <<go-guru>>

     <<protobuf-mode>>

     <<yaml-mode>>

     <<virtualenvwrapper>>

     <<jedi>>

     <<hoon-mode>>

     <<gdscript-mode>>

     <<docker>>

     <<lua-mode>>

     <<edit-server>>

     <<erlang>>

     <<rust-mode>>

     <<cargo>>

     ;; TODO check if this works

     (quse-package lsp-mode)

     (quse-package lsp-ui :init (add-hook 'rust-mode-hook 'lsp-ui-mode))

     (quse-package lsp-rust :init (setf lsp-rust-rls-command '("rustup" "run" "nightly" "rls")))

     ;; end TODO check

     <<toml-mode>>

     <<mediawiki>>

     (quse-package (xelb :fetcher github :repo "emacs-exwm/xelb"))
     (quse-package (exwm :fetcher github :repo "emacs-exwm/exwm"))

     (quse-package erc-twitch
       :preface
       (declare-function erc-twitch-enable "erc-twitch")
       :config
       (erc-twitch-enable))

     (use-package zone
       :init
       (defun lock-screen () ; TODO: pick a random function, show it, zone on that
         ;; https://www.reddit.com/r/lisp/comments/dprpt6/is_there_a_way_to_get_every_symbol_that_is_of/f5yb5fi/
         ;;
         ;; CL code:
         ;; (let (list)
         ;;   (do-all-symbols (x)
         ;;     (when (and (fboundp x)
         ;;           (not (macro-function x))
         ;;           (not (special-operator-p x)))
         ;;       (push x list)))
         ;;   list)
         "Lock screen using (zone) and xtrlock
      calls M-x zone on all frames and runs xtrlock"
         (interactive)
         (save-excursion
           ;; (shell-command "xtrlock &")
           (set-process-sentinel
            (start-process "xtrlock" nil "xtrlock")
            #'(lambda ()
                (zone-leave-me-alone)))
           (zone-when-idle 1)))
       :commands (zone-leave-me-alone zone-when-idle))

     (quse-package mingus)

     (quse-package (mingus-header-mode :repo "atheriel/mingus-header-mode" :fetcher github)
       :init (add-hook 'mingus-playlist-hooks 'mingus-header-mode))

     (quse-package elm-mode :init (setf elm-format-on-save t))

     (quse-package haskell-mode)

     ;; TODO Find a replacement as Intero seems to have stopped working and has
     ;; definitely stopped getting updates.
     (quelpa 'intero)
     (add-to-list 'package-selected-packages 'intero)
     (add-hook 'haskell-mode-hook 'intero-mode)
     (setf haskell-stylish-on-save t)

     (quse-package fsharp-mode)

     ;; I'm building this in Guix at the moment. The environment I'm using looks
     ;; like this.
     ;;
     ;; guix shell -r ~/.emacs.d/pdf-tools-environment --pure emacs bash grep sed gawk gcc-toolchain autoconf automake pkg-config make zlib gobject-introspection cairo libpng poppler -- emacs
     ;;
     ;; Add AC_USE_SYSTEM_EXTENSIONS to the checks in server's configure.ac;
     ;; #include config.h at the top of synctex_parser.c. This fixes
     ;; vedang/pdf-tools#282.
     ;;
     ;; Then (pdf-tools-install nil t) from inside Emacs.
     (quse-package pdf-tools
       :config (pdf-loader-install))

     (savehist-mode)

     (quse-package golden-ratio
       :init
       (golden-ratio-mode)
       (define-advice select-window
           (:after (_window &optional _no-record) golden-ratio-resize-window)
         (golden-ratio)
         nil))

     (quse-package switch-window
       :bind (("C-x o" . switch-window)
              ("C-x 1" . switch-window-then-maximize)
              ("C-x 2" . switch-window-then-split-below)
              ("C-x 3" . switch-window-then-split-right)
              ("C-x 0" . switch-window-then-delete)))

     (quse-package zig-mode)

     (quse-package ox-pandoc)

     (quse-package (bug-hunter :fetcher github :repo "Malabarba/elisp-bug-hunter"))

     (quse-package (inform7-mode :fetcher github :repo "fred-o/inform7-mode"))

     (quse-package helpful
       :bind (("C-h f" . helpful-callable)
              ("C-h F" . helpful-function)
              ("C-h v" . helpful-variable)
              ("C-h k" . helpful-key)
              ("C-c C-d" . helpful-at-point)))

     (quelpa 'fuel)
     (add-to-list 'package-selected-packages 'fuel)
     (use-package fuel-mode
       :init (setf fuel-factor-root-dir (getenv "FACTOR_ROOT")))

     (quse-package (fast-scroll :fetcher github :repo "ahungry/fast-scroll")
       :config
       (fast-scroll-config)
       (fast-scroll-advice-scroll-functions))

     (quse-package elpher)

     (quse-package gnu-apl-mode)

     <<envrc>>

     <<save-package-selected-packages>>
   #+END_SRC
