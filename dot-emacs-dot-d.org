#+TITLE: =.emacs.d=
#+AUTHOR: Jacob MacDonald

#+BEGIN_SRC text :tangle UNLICENSE :padline no
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
  software, either in source code form or as a compiled binary, for any purpose,
  commercial or non-commercial, and by any means.

  In jurisdictions that recognize copyright laws, the author or authors of this
  software dedicate any and all copyright interest in the software to the public
  domain. We make this dedication for the benefit of the public at large and to
  the detriment of our heirs and successors. We intend this dedication to be an
  overt act of relinquishment in perpetuity of all present and future rights to
  this software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
  AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
#+END_SRC

Emacs is by far the most important application I use to develop. It is also the
most fun to configure application I use, period. That means configuring it can
be a daunting task. This document is my attempt to create an Emacs setup that
is comprehensive and easy to extend. To this end, I've made it a literate Org
file, which means it is organized, easy to modify, and easily convertible to
web page. It is also version controlled.

Now, for some code.

* Bootstrap.

  To load various packages and initialize them succinctly, I use =quelpa= and
  =use-package=. =quelpa= builds packages from source so I can stay on the
  bleeding edge. =use-package= loads and initializes the packages in a compact
  and readable macro. Unfortunately, one cannot load those packages using
  them. Fortunately, the bootstrapping process is relatively painless.

  The =quelpa= bootstrap snippet comes straight from the project's GitHub
  page. I use the non-auto-updating version.

  #+NAME: quelpa
  #+BEGIN_SRC emacs-lisp
    (package-initialize)
    (setf quelpa-update-melpa-p nil)
    (unless (require 'quelpa nil t)
      (with-temp-buffer
        (url-insert-file-contents
         "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
        (eval-buffer)))
  #+END_SRC

  Apparently a certain package breaks =quelpa= in certain circumstances. This
  snippet fixes this problem.

  #+NAME: async-bytecomp-allowed-packages
  #+BEGIN_SRC emacs-lisp
    (setf async-bytecomp-allowed-packages nil)
  #+END_SRC

  Because of the last snippet, =use-package= can be downloaded using the
  =quelpa= function, but it must be loaded manually. (Manually being a
  one-liner. :-)

  #+NAME: use-package
  #+BEGIN_SRC emacs-lisp
    (quelpa 'use-package)
    (require 'use-package)
  #+END_SRC

  After the actual boostrapping I can use a small convenience macro I wrote
  myself to combine =quelpa= and =use-package=. It is called =quse-package= and
  is fetched via (you guessed it) =quelpa=.

  #+NAME: quse-package
  #+BEGIN_SRC emacs-lisp
    (quelpa '(quse-package :fetcher github :repo "jaccarmac/quse-package"))
    (require 'quse-package)
  #+END_SRC

* Improve Emacs' interface.

  Vanilla Emacs is usable, but not usable enough to allow me to be
  productive. A few small packages allow me to actually function in the editor.

  Phil Hagelberg's =better-defaults= is a good start, including several
  one-line configuration options and usability rebinds.

  #+NAME: better-defaults
  #+BEGIN_SRC emacs-lisp
    (quse-package better-defaults)
  #+END_SRC

  On top of the sensible settings in =better-defaults=, I like to set
  =fill-column= to a sane value that doesn't depend on Emacs' frame
  size.

  #+NAME: fill-column
  #+BEGIN_SRC emacs-lisp
    (setq-default fill-column 79)
  #+END_SRC

  Unix UTF-8 encoding is a better sensible default for encoding than whatever
  platform-dependent value Emacs uses by default.

  #+NAME: prefer-coding-system
  #+BEGIN_SRC emacs-lisp
    (prefer-coding-system 'utf-8-unix)
  #+END_SRC

  It's also nice to not have to deal with the splash screen every time Emacs
  starts.

  #+NAME: inhibit-splash-screen
  #+BEGIN_SRC emacs-lisp
    (setq-default inhibit-splash-screen t)
  #+END_SRC

  Exposing Emacs' multi-branch undo and redo feature graphically is
  fantastically useful. Tony Cubitt's =undo-tree-mode= does just that.

  #+NAME: undo-tree
  #+BEGIN_SRC emacs-lisp
    (quse-package undo-tree
                  :init (global-undo-tree-mode))
  #+END_SRC

  Donald Ephraim Curtis had made a great port of Vim Powerline. It is helpful
  for keeping track of location in a file, and it looks pretty.

  #+NAME: powerline
  #+BEGIN_SRC emacs-lisp
    (quse-package powerline
                  :init (powerline-default-theme))
  #+END_SRC

  I have used many themes for Emacs during my time using it. I tend to come
  back to kuanyui's =moe-theme= due to its amount of contrast and variety of
  faces.

  #+NAME: moe-theme
  #+BEGIN_SRC emacs-lisp
    (quse-package moe-theme
                  :config (load-theme 'moe-dark t))
  #+END_SRC

  The =smartparens= package is like =paredit= plus a bunch of nice extras. I
  enable the strict mode globally and use the maintainer's default keybindings.

  #+NAME: smartparens
  #+BEGIN_SRC emacs-lisp
    (quse-package smartparens
                  :init (progn
                          (smartparens-global-mode)
                          (smartparens-global-strict-mode)
                          (require 'smartparens-config)
                          (sp-use-smartparens-bindings)))
  #+END_SRC

* Install a recent version of Org mode.

  It works fine without installing the bleeding edge, but that's no fun. And
  installing the bleeding edge is just too easy...

  #+NAME: org
  #+BEGIN_SRC emacs-lisp
    (quse-package (org :fetcher git
                       :url "git://orgmode.org/org-mode.git"
                       :files ("lisp/*.el"
                               "contrib/lisp/*.el"
                               "doc/dir"
                               "doc/*.texi")))
  #+END_SRC

* Manage my money.

  Ledger is a fantastic personal accounting application. It has a ton of
  features, but it relatively easy to configure in plain text. It comes with an
  Emacs mode.

  #+NAME: ledger-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package ledger-mode
                  :init (add-to-list 'auto-mode-alist
                                     '("ledger/.*\\.dat\\'" . ledger-mode)))
  #+END_SRC

* Generate and secure passwords.

  I use =password-store= to manage and generate all my passwords. This utility
  stores passwords in text files encrypted by my GPG key, and can copy them to
  the system clipboard when I need to use them. A work-in-progress Emacs mode
  is included in the distribution and cloned and installed in the following
  snippet.

  #+NAME: password-store
  #+BEGIN_SRC emacs-lisp
    (quse-package password-store)
  #+END_SRC

* Manage projects.

  One-off-file hacking is great, but most of what I do is done in the context
  of a project, often one too big to fit inside my head. The following packages
  integrate tools that do the legwork of project management with Emacs.

  Bozhidar Batsov's =projectile= is an all-inclusive project management
  navigator and indexer for Emacs. The indexing it does is especially useful,
  letting you grep an entire project with a simple key chord.

  #+NAME: projectile
  #+BEGIN_SRC emacs-lisp
    (quse-package projectile
                  :init (progn
                          (projectile-global-mode)
                          (setf projectile-switch-project-action
                                'projectile-dired)))
  #+END_SRC

  Git is the modern king of version control. The Magit project turns Emacs into
  an extremely powerful interface to it. I find that key chords are much more
  efficient than terminal commands after a few days' practice.

  #+NAME: magit
  #+BEGIN_SRC emacs-lisp
    (quse-package magit)
  #+END_SRC

* Complete symbols.

  It's nearly impossible to work with large projects or avoid misspellings
  without a good, always-accessible completion framework. The Emacs community
  is split between using Company and Auto-Complete. I've used Auto-Complete for
  quite a while and have no pressing reason to switch. Its initialization is
  rather simple; Sources are initialized later with the modes they are
  associated with.

  #+NAME: auto-complete
  #+BEGIN_SRC emacs-lisp
    (quse-package auto-complete
                  :init (progn (require 'auto-complete-config)
                               (ac-config-default)))
  #+END_SRC

* Clojure.

  Clojure is a fantastic Lisp that gives me access to the JVM without having to
  deal with Java.

  CIDER is, in my opinion, the best way to edit Clojure in Emacs, bar
  none. Loading is done in the standard quelpa way; The configuration options
  are taken from CIDER's GitHub page. I prefer Boot over Leiningen, so I set
  Boot as my default REPL.

  #+NAME: cider
  #+BEGIN_SRC emacs-lisp
    (quse-package cider
                  :init (progn
                          (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
                          (setf cider-repl-tab-command 'indent-for-tab-command)
                          (setf cider-default-repl-command "boot")))
  #+END_SRC

  CIDER can be integrated with Auto-Complete painlessly by using the ac-cider
  package.

  #+NAME: ac-cider
  #+BEGIN_SRC emacs-lisp
    (quse-package ac-cider
                  :init (progn (add-hook 'cider-mode-hook 'ac-cider-setup)
                               (add-hook 'cider-repl-mode-hook 'ac-cider-setup)))
  #+END_SRC

* Hack with Common Lisp.

  While most of my Lisp-writing has been in Clojure, the majority of my
  Lisp-learning has been in Common Lisp. Fanboys say there's nothing you can't
  do with CL, and, while I don't have enough experience to confirm or deny
  this, I always enjoy exploring the language. The Emacs/CL ecosystem is
  amazing as well.

  SLIME is indescribably good. 'Nuff said. As for the configuration, I set SBCL
  as my preferred Lisp, and tell SLIME to look fancy. In addition, I tell SLIME
  where to find the Common Lisp Hyperspec so I can look up HTML documentation
  on the fly.

  #+NAME: slime
  #+BEGIN_SRC emacs-lisp
    (quse-package slime
                  :init (progn
                          (setf inferior-lisp-program "sbcl")
                          (setf common-lisp-hyperspec-root
                                (getenv "HYPERSPEC_ROOT"))
                          (setf slime-contribs '(slime-fancy))
                          (slime-setup)))
  #+END_SRC

  Integrating Auto-Complete and SLIME is painless, thanks to the work of Steve
  Purcell.

  #+NAME: ac-slime
  #+BEGIN_SRC emacs-lisp
    (quse-package ac-slime
                  :init (progn (add-hook 'slime-mode-hook 'set-up-slime-ac)
                               (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
                               (eval-after-load "auto-complete"
                                 '(add-to-list 'ac-modes 'slime-repl-mode))))
  #+END_SRC

* Edit web applications.

  Managing modes to edit the dozens of new file formats for a new web project
  every month is a nightmare. So much so I don't like to talk about it. I've
  found that =web-mode.el= does a pretty good job of managing them
  automagically. I use the version from which I sometimes submit pull
  requests. Setting ~web-mode-enable-engine-detection~ allows the mode to pick
  up on ~-*-~-style comments at the top of files.

  #+NAME: web-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package web-mode
                  :init (progn
                          (setf web-mode-enable-engine-detection t)
                          (add-to-list 'auto-mode-alist
                                       '("\\.html?\\'" . web-mode))
                          (add-to-list 'auto-mode-alist
                                       '("\\.css?\\'" . web-mode))
                          (add-to-list 'auto-mode-alist
                                       '("\\.js?\\'" . web-mode))
                          (add-to-list 'auto-mode-alist
                                       '("\\.php?\\'" . web-mode))
                          (add-to-list 'auto-mode-alist
                                       '("\\.tmpl?\\'" . web-mode))))
  #+END_SRC

* Steal Java-editing features from Eclipse.

  Trying to edit Java with just Emacs is a nightmare. I tried it for a while,
  but eventually caved into practicality and installed Eclipse, eclim, and
  =emacs-eclim=. The trio of software packages work together to use Eclipse's
  editing features and completion in Emacs. The configuration here comes
  straight from the =emacs-eclim= website, converted to a slightly strange form
  because of the project's package structure.

  #+NAME: emacs-eclim
  #+BEGIN_SRC emacs-lisp
    (quelpa 'emacs-eclim)
    (use-package eclim :config (global-eclim-mode))
    (use-package ac-emacs-eclim-source :config (ac-emacs-eclim-config))
  #+END_SRC

** Include YASnippet.

   Some features of =emacs-eclim= depend on having YASnippet, a popular Emacs
   snippet package, installed. I don't use YASnippet directly, only through
   =emacs-eclim=, but I may change my mind in the future.

   #+NAME: yasnippet
   #+BEGIN_SRC emacs-lisp
     (quse-package yasnippet)
   #+END_SRC

* Edit and complete Nim.

  Nim is a systems programming languages that compiles to C, C++, ObjC, and
  JavaScript. It's the latest toy language I am trying to learn.

  #+NAME: nim-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package nim-mode)
  #+END_SRC

* View Markdown.

  I prefer Org to Markdown in every situation, but sometimes it is necessary to
  be able to read Markdown. Good thing there's a mode on MELPA!

  #+NAME: markdown-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package markdown-mode)
  #+END_SRC

* Edit and complete Go.

  I have fun with Go, and it's as simple as that :-). Its tooling for Emacs
  follows the theme of the rest of the tooling I use: It's simple and easy to
  install.

  #+NAME: go-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package go-mode)
  #+END_SRC

  #+NAME: go-autocomplete
  #+BEGIN_SRC emacs-lisp
    (quse-package go-autocomplete)
  #+END_SRC

* Edit Protocol Buffer files.

  Google's Protocol Buffers are a data exchange format useful for quick
  over-the-wire messages. The canonical implementation comes with a major mode
  for editing a Protocol Buffer definition.

  #+NAME: protobuf-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package (protobuf-mode :fetcher github
                                 :repo "google/protobuf"
                                 :files ("editors/protobuf-mode.el")))
  #+END_SRC

* YAML.

  "Yet Another Markup Language" indeed. It's the wrong acronym. Sue me. Ugh.

  #+NAME: yaml-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package yaml-mode)
  #+END_SRC

* Edit and complete Python.

  There are quite a few options for this in Emacs. The one I have found to be
  the most useful personally is Jedi, which is relatively minimal as full
  language environments go. It hooks up to a Python component which must be
  installed separately. The following snippet is the minimal Jedi setup taken
  from Jedi's own documentation. I choose to override Emacs jump-to shortcuts
  with Jedi's.

  #+NAME: jedi
  #+BEGIN_SRC emacs-lisp
    (quse-package jedi
                  :init (progn
                          (add-hook 'python-mode-hook 'jedi:setup)
                          (setf jedi:complete-on-dot t)
                          (setf jedi:use-shortcuts t)))
  #+END_SRC

  Unfortunately, Jedi does not handle virtual environments by itself, so we
  need to install and configure the =virtualenvwrapper.el= package for
  everything to work properly.

  #+NAME: virtualenvwrapper
  #+BEGIN_SRC emacs-lisp
    (quse-package virtualenvwrapper
                  :init (progn
                          (venv-initialize-interactive-shells)
                          (venv-initialize-eshell)))
  #+END_SRC

* Edit Hoon files.

  Hoon is a somewhat esoteric programming language created and used on the
  functional Urbit operating system. The Urbit distribution contains an Emacs
  mode.

  #+NAME: hoon-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package (hoon-mode :fetcher github
                             :repo "urbit/urbit"
                             :files ("extras/hoon-mode.el/hoon-mode.el")))
  #+END_SRC

* Edit GDScript files.

  The Godot game engine uses a Python-like scripting language. Their built-in
  editor is not the greatest, so why not use Emacs to edit scripts instead?

  #+NAME: gdscript-mode
  #+BEGIN_SRC emacs-lisp
    (quse-package (gdscript-mode :fetcher github
                                 :repo "jaccarmac/gdscript-mode"
                                 :branch "package-header"))
  #+END_SRC

* Tangle source code.

  All files get tangled to the directory that this file is in.

** =init.el=

   #+BEGIN_SRC emacs-lisp :noweb no-export :tangle init.el :padline no
     <<quelpa>>

     <<async-bytecomp-allowed-packages>>

     <<use-package>>

     <<quse-package>>

     <<better-defaults>>

     <<fill-column>>

     <<prefer-coding-system>>

     <<inhibit-splash-screen>>

     <<undo-tree>>

     <<powerline>>

     <<moe-theme>>

     <<smartparens>>

     <<org>>

     <<ledger-mode>>

     <<password-store>>

     <<projectile>>

     <<magit>>

     <<auto-complete>>

     <<cider>>

     <<ac-cider>>

     <<slime>>

     <<ac-slime>>

     <<web-mode>>

     <<emacs-eclim>>

     <<yasnippet>>

     <<nim-mode>>

     <<markdown-mode>>

     <<go-mode>>

     <<go-autocomplete>>

     <<protobuf-mode>>

     <<yaml-mode>>

     <<jedi>>

     <<virtualenvwrapper>>

     <<hoon-mode>>

     <<gdscript-mode>>
   #+END_SRC
