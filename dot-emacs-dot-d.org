Emacs is by far the most important application I use to develop. It is also the
most fun to configure application I use, period. That means configuring it can
be a daunting task. This document is my attempt to create an Emacs setup that
is comprehensive and easy to extend. To this end, I've made it a literate Org
file, which means it is organized, easy to modify, and easily convertible to
web page. It is also version controlled.

Now, for some code.

* Bootstrap.
  
  To load various packages and initialize them succinctly, I use =quelpa= and
  =use-package=. =quelpa= builds packages from source so I can stay on the
  bleeding edge. =use-package= loads and initializes the packages in a compact
  and readable macro. Unfortunately, one cannot load those packages using
  them. Fortunately, the bootstrapping process is relatively painless.
  
  The =quelpa= bootstrap snippet comes straight from the project's GitHub
  page. I use the non-auto-updating version.
  
  #+NAME: quelpa
  #+BEGIN_SRC emacs-lisp
    (package-initialize)
    (unless (require 'quelpa nil t)
      (with-temp-buffer
        (url-insert-file-contents
         "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
        (eval-buffer)))
  #+END_SRC
  
  Because of the last snippet, =use-package= can be downloaded using the
  =quelpa= function, but it must be loaded manually. (Manually being a
  one-liner. :-)
  
  #+NAME: use-package
  #+BEGIN_SRC emacs-lisp
    (quelpa 'use-package)
    (require 'use-package)
  #+END_SRC
  
* Improve Emacs' interface.
  
  Vanilla Emacs is usable, but not usable enough to allow me to be
  productive. A few small packages allow me to actually function in the editor.
  
  Phil Hagelberg's =better-defaults= is a good start, including several
  one-line configuration options and usability rebinds.
  
  #+NAME: better-defaults
  #+BEGIN_SRC emacs-lisp
    (quelpa 'better-defaults)
    (use-package better-defaults)
  #+END_SRC
  
  Exposing Emacs' multi-branch undo and redo feature graphically is
  fantastically useful. Tony Cubitt's =undo-tree-mode= does just that.
  
  #+NAME: undo-tree
  #+BEGIN_SRC emacs-lisp
    (quelpa 'undo-tree)
    (use-package undo-tree
      :init (global-undo-tree-mode))
  #+END_SRC
  
  Donald Ephraim Curtis had made a great port of Vim Powerline. It is helpful
  for keeping track of location in a file, and it looks pretty.
  
  #+NAME: powerline
  #+BEGIN_SRC emacs-lisp
    (quelpa 'powerline)
    (use-package powerline
      :init (powerline-default-theme))
  #+END_SRC
  
  I have used many themes for Emacs during my time using it. I tend to come
  back to kuanyui's =moe-theme= due to its amount of contrast and variety of
  faces.
  
  #+NAME: moe-theme
  #+BEGIN_SRC emacs-lisp
    (quelpa 'moe-theme)
    (use-package moe-theme
      :init (load-theme 'moe-dark t))
  #+END_SRC
  
  I'm a lazy Lisper, so I have never taken the time to learn =paredit=
  properly. Matus Goljer has created a =smartparens= package that makes many
  paren-editing commands automatic.
  
  #+NAME: smartparens
  #+BEGIN_SRC emacs-lisp
    (quelpa 'smartparens)
    (use-package smartparens
      :init (smartparens-global-mode))
  #+END_SRC

* Manage my money.

  Ledger is a fantastic personal accounting application. It has a ton of
  features, but it relatively easy to configure in plain text. It comes with an
  Emacs mode.

  #+NAME: ledger-mode
  #+BEGIN_SRC emacs-lisp
    (quelpa 'ledger-mode)
    (use-package ledger-mode)
  #+END_SRC
  
* Manage projects.
  
  One-off-file hacking is great, but most of what I do is done in the context
  of a project, often one too big to fit inside my head. The following packages
  integrate tools that do the legwork of project management with Emacs.
  
  Bozhidar Batsov's =projectile= is an all-inclusive project management
  navigator and indexer for Emacs. The indexing it does is especially useful,
  letting you grep an entire project with a simple key chord.
  
  #+NAME: projectile
  #+BEGIN_SRC emacs-lisp
    (quelpa 'projectile)
    (use-package projectile
      :init (projectile-global-mode))
  #+END_SRC
  
  Git is the modern king of version control. The Magit project turns Emacs into
  an extremely powerful interface to it. I find that key chords are much more
  efficient than terminal commands after a few days' practice.
  
  #+NAME: magit
  #+BEGIN_SRC emacs-lisp
    (quelpa 'magit)
    (use-package magit)
  #+END_SRC
  
* Complete symbols.
  
  It's nearly impossible to work with large projects or avoid misspellings
  without a good, always-accessible completion framework. The Emacs community
  is split between using Company and Auto-Complete. I've used Auto-Complete for
  quite a while and have no pressing reason to switch. Its initialization is
  rather simple; Sources are initialized later with the modes they are
  associated with.
  
  #+NAME: auto-complete
  #+BEGIN_SRC emacs-lisp
    (quelpa 'auto-complete)
    (use-package auto-complete
      :init (progn (require 'auto-complete-config)
                   (ac-config-default)))
  #+END_SRC

* Clojure.

  Clojure is a fantastic Lisp that gives me access to the JVM without having to
  deal with Java.

  CIDER is, in my opinion, the best way to edit Clojure in Emacs, bar
  none. Loading is done in the standard quelpa way; The configuration options
  are taken from CIDER's GitHub page.

  #+NAME: cider
  #+BEGIN_SRC emacs-lisp
    (quelpa 'cider)
    (use-package cider
      :init (progn (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
                   (setq cider-repl-tab-command 'indent-for-tab-command)))
  #+END_SRC

  CIDER can be integrated with Auto-Complete painlessly by using the ac-cider
  package.

  #+NAME: ac-cider
  #+BEGIN_SRC emacs-lisp
    (quelpa 'ac-cider)
    (use-package ac-cider
      :init (progn (add-hook 'cider-mode-hook 'ac-cider-setup)
                   (add-hook 'cider-repl-mode-hook 'ac-cider-setup)))
  #+END_SRC

* Hack with Common Lisp.

  While most of my Lisp-writing has been in Clojure, the majority of my
  Lisp-learning has been in Common Lisp. Fanboys say there's nothing you can't
  do with CL, and, while I don't have enough experience to confirm or deny
  this, I always enjoy exploring the language. The Emacs/CL ecosystem is
  amazing as well.

  SLIME is indescribably good. 'Nuff said. As for the configuration, I set SBCL
  as my preferred Lisp, and tell SLIME to look fancy. In addition, I tell SLIME
  where to find the Common Lisp Hyperspec so I can look up HTML documentation
  on the fly.

  #+NAME: slime
  #+BEGIN_SRC emacs-lisp
    (quelpa 'slime)
    (use-package slime
      :init (progn (setq inferior-lisp-program "sbcl")
                   (setq common-lisp-hyperspec-root "/usr/share/doc/hyperspec/")
                   (setq slime-contribs '(slime-fancy))
                   (slime-setup)))
  #+END_SRC

  Integrating Auto-Complete and SLIME is painless, thanks to the work of Steve
  Purcell.

  #+NAME: ac-slime
  #+BEGIN_SRC emacs-lisp
    (quelpa 'ac-slime)
    (use-package ac-slime
      :init (progn (add-hook 'slime-mode-hook 'set-up-slime-ac)
                   (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
                   (eval-after-load "auto-complete"
                     '(add-to-list 'ac-modes 'slime-repl-mode))))
  #+END_SRC

* Tangle source code.
  
  All files get tangled to =tangled=, which is a subdirectory of the directory
  that this file is in.
  
** =init.el=
   
   #+BEGIN_SRC emacs-lisp :noweb no-export :mkdirp yes :tangle tangled/init.el
     <<quelpa>>

     <<use-package>>

     <<better-defaults>>

     <<undo-tree>>

     <<powerline>>

     <<moe-theme>>

     <<smartparens>>

     <<ledger-mode>>

     <<projectile>>

     <<magit>>

     <<auto-complete>>

     <<cider>>

     <<ac-cider>>

     <<slime>>

     <<ac-slime>>
   #+END_SRC
